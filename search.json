[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Grammar of Experimental Designs",
    "section": "",
    "text": "The book will include about the basics of experimental design and how to get started with the edibble R-package and its extensions to plan, design and simulate experiments.\nThe concept and the development of the edibble R-package and its extensions have been my long-standing passion project. I’ve designed experiments in practice and taught experimental design in undergraduate statistics courses but felt the friction in the system to construct the experimental design. For some years, I’ve thought about doing something in the area of experimental design research and whenever I go to conferences, I would attend any talks about experimental design (which there are not many of!). With the rise of popularity in tidyverse and the development of tsibble, coupled with my own interest and skill in software development, I came up with the idea of edibble in early 2019 – some of these sketches are shown below. I sketched out the proof of concept that year and have been developing it ever since.\n\n\nSketches from 2019\n\nIf you know the present system, you’ll notice how it’s evolved from the original idea!\n\n\n\n\n\n\n\n\n\n\n\n\nIf I was any good, I would have finished developing this sooner, but the project is far different to all my past research projects and truthfully, I get distracted easily, take on far too many service jobs, put enormous effort into my teaching and do other research activities to actually have had time for this project. But in the little time I had, working on this has brought me joy. If I care about just climbing up the academic ladder, I wouldn’t work on this project – it’s far too inefficient for that purpose. It’s my belief that this project will make a significant positive difference in the world, particularly for scientific studies, and I hope you find that too.\nAn experimental design is a huge field, and no doubt I know only a small portion of it. So if you find mistakes or I’m not giving enough due attention or credit to an important concept, please feel to let me know."
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Preface",
    "section": "",
    "text": "The book can also serve as a reference to both undergraduate and graduate courses. Each section has problems that can be used as exercise for students. The book can also be used by practitioners that are involved with scientific or industrial experiments. The book will include plenty of examples spanning a diverse range of disciplines.\nIt is beneficial to have at least some knowledge of R. Readers may like to read XXX for basic knowledge in R and “R for Data Science” for tidyverse approaches to data analysis in R.\nThe book primarily makes use of ggplot2 for drawing static plots. The default color scheme and theme are modified as below and are applied for all plots produced by ggplot2 henceforth."
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "1  Basics",
    "section": "",
    "text": "If the design of an experiment is faulty, any method of interpretation which makes it out to be decisive must be faulty too.\n–Fisher, 1935, Design of Experiments\nData is a resultant reality, as such any examination of the data to answer questions in a satisfying manner require comprehension of the origin of the data, i.e. how was the data collected? For experimental data, this includes knowing the experimental aim and design.\nThere are many articles and books dedicated to explaining the concepts of experimental designs. This includes the seminal book by Fisher (1935), Bailey (2008), etc. This chapter presents an overview of the statistical concepts that are most pertinent in designing an experiment.\nMost experiments are comparative in nature, or more specifically, most experiments involve study of two or more experimental conditions in which the primary interest is to compare the outcome under the different conditions. You’ll therefore find that most experiments in this book are comparative experiments.\nAt the heart of each experiment, we are ultimately seeking confidence in any conclusion we are making from the analysis of the experimental data. What is perhaps not emphasised enough is that the experiments are human endeavours. Often there are multiple people involved in running experiments and a key challenge is to ensure each individual has sufficient understanding to play their role well. We touch more on this in Chapter 4.\nAll experiments have a cost whether that be financial, resources, time or other. We can consider the experimental cost as a function of the ability to redo the experiment again. For example, if your experimental resources are based on examination of fossils and the fossils are destroyed in the experimental process, then the cost of the experiment is infinite – you only have one chance to do the experiment – so it’s absolutely essential that you plan, design and execute the experiment well.\nDoing an experiment well requires a good understanding of the subject matter so that potential sources of variation can be controlled or accounted for in the experimental design. Prior to the collection of data, the statistical component of an experiment tends to be focussed on the design of the experiment, i.e. how the treatments are assigned to experimental units under practical constrains to maximise the statistical information of interest. Under this consideration, the statistical problem for experimental design is often reduced to either a randomisation or an optimisation problem and the experimental context may be stripped away in the generation of the design using computer software. We discuss this in ?sec-context, then describe a system that encourages higher order thinking of the experimental design, termed the grammar of experimental designs, in Chapter 2, implemented as the edibble R-package and present how to get started with the edibble system to construct experimental design in Chapter 3.\nBefore we get into the crux of the basics of the experimental design, consider the three scenarios below. Each scenario describes an experiment where technical details have been reduced so it doesn’t serve as a distraction for now. For each scenario, try to see if you can identify what are the basic components to build the design of the experiment."
  },
  {
    "objectID": "basics.html#sec-terminology",
    "href": "basics.html#sec-terminology",
    "title": "1  Basics",
    "section": "1.1 Basic terminology",
    "text": "1.1 Basic terminology\nThe field of experimental design is large and is applied to many domains, e.g. biology, psychology, industry, finance, marketing and so on. While some specialised terminology exist, the following terminology are basic terms that are commonly understood across domains:\n\n\n\n\n\n\nUnit related\n\n\n\n\nexperimental unit: the smallest unit in which the treatment can independently be applied,\nobservational unit: the smallest unit in which the response is measured on,\nblock or cluster: the grouping of another unit such that the units within the same block or cluster is more alike in some aspect than units in different blocks or clusters,\nunit structure: the relation between the units, e.g. pots nested in particular glasshouses, subjects segregated by sex, and so on\n\n\n\n\n\n\n\n\n\nTreatment related\n\n\n\n\ntreatments: the whole set of experimental conditions in which the units are subjected to,\ntreatment structure: the division of treatment levels to meaningful groups, e.g. factorial structure means all combinations across the different treatment factors,\ncontrol in treatment refers to a standard approach used, e.g. chemotherapy is a standard way to treat patients with particular cancers, and\nplacebo means a treatment designed to\n\n\n\n\n\n\n\n\n\nExperiment related\n\n\n\n\ndesign: the allocation of treatment to units,\nplan or layout: the actual assignment of treatment to units, and\nexperimental structure: the arrangements or constrains of experimental factors – the structure can be broadly categorised as unit and treatment structure.\n\n\n\nThe above terminology describe the experimental factors and its associations. More specifically, experimental factors are any variables that pertain to the experiment (physical or otherwise) and includes the treatments, experimental units, observational units and blocks/clusters. The associations of experimental factors include its nesting structure or say the assignment of treatment to units.\nIn addition to above, there are commonly understood terminology that refer to the properties of experimental designs. These include:\n\nbalanced experiment: refers to when the replication of the treatments are equal,\northogonal design\ncomplete block design: every treatment appears exactly once in each block or cluster, otherwise it is referred to as incomplete block design,\nblinded experiments, relevant only to studies involving human subjects, refers to experiments where subjects are not informed about which treatment they received. Double-blinded studies means that both those administrating and receipient of the treatment are not informed about the actual treatment.\n\n\n\n\n\n\n\n plant growth\n\n\n\n\nThe experimental aim is to study the effects of plant growth of four particular bacterial strains.\nThe experimental units are …\n\n\n\n\n1.1.1 Specialised terminology\nExperimental design is applicable across numerous domains, so perhaps it is not surprising that there are domain specific or specialised terminology that is used to describe the whole experimental designs, e.g. Latin Square Design, Step-Wedge Trial, Beehive Design and so on. Some recipe of these named experimental design are presented and discussed in Chapter Section 5."
  },
  {
    "objectID": "basics.html#principles",
    "href": "basics.html#principles",
    "title": "1  Basics",
    "section": "1.2 Principles",
    "text": "1.2 Principles\nAll experiments have a potential to go wrong – plans may not be followed to the letter; you can’t distinguish which factor had the effect; or unknown factor is affecting the response. The degree of how wrong it went can vary but in some cases you wouldn’t even know it went wrong!\nIn designing an experiment, there are some safety measures that you can put in place to minimise potential issues. The basic statistical principles of experimental design outlined below form some of these safety measures.\n\n1.2.1 Randomisation\nRandomisation in the context of experimental design means that the treatment allocation to units were probabilistically determined by a mechanism where the outcome of the allocation is not (consciously or unconsciously) influenced by those involved in the experiment. The opposite spectrum of randomisation is systematic allocations of treatments to units – this means that the allocations are not probabilistic and if you know the systematic order, then you can precisely infer the allocation.\nRandomisation is a core principle of experimental design. When you conduct an experiment, you are investigating factors to understand some process or phenomenon, and there will be factors which affect the response that you don’t know about – if you did, you could try to control that variable in your experiment. Randomisation protects the experiment, with no guarantee however, from potential bias.\n\n\n\n\n\n\nHow to randomise\n\n\n\nTypically you can use some software to draw a random sample; in this instance it’d be a good idea to ensure this randomisation can be replicated. In R, this is typically achieved by using set.seed().\nIn some cases, you can use physical tools to do your randomisation so long as the tool doesn’t introduce some bias. E.g. flipping an unbiased coin or blindly drawing a paper with a number written from a covered box. While it’s easier to replicate the randomisation using a computational tool like R, it’s far more important to present the treatment allocation in a manner that the subjects involved in the experiment can accept it. For example, a water-sensitive revitalisation is planned for settlements in a developmental country such that half the settlements will be allocated to early intervention, the other half late intervention. The local community doesn’t have an understanding about randomisation but the concept of lottery is familiar – a grand ceremony is taken place with representative of the settlements drawing out a ball that allocates the settlement to early or late intervention.\n\n\nNot all experiments can allocate treatments to units randomly, e.g. you can’t get your participants to smoke to study the effect of smoking, nor can you get a random agricultural land to have a drought to study how well a crop grows under drought conditions. These types of experiments are referred to as quasi-experiments or natural experiments.\n\n\n1.2.2 Optimisation\nOptimisation in the context of experimental design generally means that the treatment allocation to units were found by optimising some given criteria, usually denoted by a single letter (A, C, D, etc). These optimality-criteria are based on a statistical model, say,\n\\[\\begin{equation} \\boldsymbol{y} =  \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{e},\\end{equation}\\]\nwhere \\(\\boldsymbol{y}\\) is a vector of yet unobserved responses, \\(\\boldsymbol{\\beta}\\) is a vector of experimental factor effects (e.g. treatment, block, etc), \\(\\mathbf{X}\\) is the so-called design matrix (comprising of 0s and 1s) that map the experimental factor levels to a response, and \\(\\boldsymbol{e}\\) is a vector of errors.\n\n\n\n\n\n\n\n Design matrix for plant growth example\n\n\n\nConsider again Scenario 1 where an experiment studies three bacterial strains known for promoting plant growth under osmotic stress. The design matrix, \\(\\mathbf{X}\\), below shows the mapping of the six plant units to the baterial strain.\n\\[\\mathbf{X} = \\begin{bmatrix}1 & 0 & 0  \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 1  & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & 1\\end{bmatrix}\\qquad \\boldsymbol{\\beta} = \\begin{bmatrix}\\class{fa-solid fa-virus}{}\\\\ \\class{fa-solid fa-bacterium}{}\\\\ \\class{fa-solid fa-disease}{}\\\\ \\end{bmatrix} \\qquad \\underset{\\text{illustrative}}{\\mathbf{X}\\boldsymbol{\\beta} =  \\begin{bmatrix}\\class{fa-solid fa-virus}{} \\rightarrow \\class{fa-solid fa-seedling}{}_1\\\\\\class{fa-solid fa-virus}{} \\rightarrow \\class{fa-solid fa-seedling}{}_2\\\\\\class{fa-solid fa-bacterium}{} \\rightarrow \\class{fa-solid fa-seedling}{}_3\\\\\\class{fa-solid fa-bacterium}{} \\rightarrow \\class{fa-solid fa-seedling}{}_4\\\\\\class{fa-solid fa-disease}{} \\rightarrow \\class{fa-solid fa-seedling}{}_5\\\\\\class{fa-solid fa-disease}{} \\rightarrow \\class{fa-solid fa-seedling}{}_6\\end{bmatrix}}\\]\n\n\nIf we assume \\(\\boldsymbol{e} \\sim N(\\boldsymbol{0}, \\sigma^2\\mathbf{V})\\) where \\(\\mathbf{V}\\) is a positive definite covariance matrix (often assumed as \\(\\sigma^2\\mathbf{I}\\)) and \\(\\boldsymbol{\\beta}\\) are fixed effects, then \\(\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^\\top\\mathbf{V}^{-1}\\mathbf{X})^{-1}\\mathbf{X}^\\top\\mathbf{V}^{-1}\\boldsymbol{y}\\) and \\(var(\\hat{\\boldsymbol{\\beta}}) = \\sigma^2(\\mathbf{X}^\\top\\mathbf{V}^{-1}\\mathbf{X})^{-1}\\) where \\(\\mathbf{X}\\) is assumed to be full rank. Note that the construction of \\(\\mathbf{X}\\) is what we normally have control over at the experimental design stage.\n\n\n\n\n\n\nWhere \\(\\mathbf{X}\\) is not full rank\n\n\n\nIf \\(\\mathbf{X}\\) is not full rank, then there are many possible inverses of \\(\\mathbf{X}^\\top\\mathbf{V}^{-1}\\mathbf{X}\\), termed generalised inverse with notation as \\((\\mathbf{X}^\\top\\mathbf{V}^{-1}\\mathbf{X})^{-}\\). In these circumstances, the software generally makes choices for you (most likely without you knowing) of how either to modify \\(\\mathbf{X}\\) or the generalised inverse is constructed. In most cases this doesn’t pose any detrimental consequences as most optimal criteria tends to be invariant to the choice of the generalised inverse.\nUnder experiments with multiple factors (which is most experiments), including where interaction effects are assumed, \\(\\mathbf{X}\\) is not full rank. We assume that \\(\\mathbf{X}\\) is full rank for this book, unless there is a need to explicitly address the issue.\n\n\n\n\n\n\n\n\nWhere \\(\\mathbf{V}\\) is singular\n\n\n\nIn some software, \\(\\mathbf{V}\\) may (inadvertentnly or not) be allowed to be positive semi-definite matrix. This causes issues when \\(\\mathbf{V}\\) becomes singular or when one of the eigenvalues of \\(\\mathbf{V}\\) is near-zero and there are some strategies that the software employs to tackle these issues.\n\n\nMost optimal-criteria is based on optimising some function based on \\((\\mathbf{X}^\\top\\mathbf{V}^{-1}\\mathbf{X})^{-1}\\) or \\(\\mathbf{X}^\\top\\mathbf{V}^{-1}\\mathbf{X}\\), also known as the information matrix. The list of optimal-criteria are shown in Table XX.\n\n\n\n\n\n\n\n\nCriteria\nDescription\nNotes\n\n\n\n\nA-optimality\nminimise \\(\\text{tr}\\left((\\mathbf{X}^\\top\\mathbf{V}^{-1}\\mathbf{X})^{-1}\\right)\\)\naverage variance of the estimators of parameters of interest\n\n\nC-optimality\nminimise \\(\\text{var}(\\boldsymbol{c}^\\top\\hat{\\boldsymbol{\\beta}})\\) where \\(\\boldsymbol{c}\\) is pre-determined vector of constants\n\n\n\nD-optimality\nmaximise \\(\\text{det}\\left(\\mathbf{X}^\\top\\mathbf{V}^{-1}\\mathbf{X}\\right)\\)\nsometimes this is adjusted to \\([\\text{det}\\left(\\mathbf{X}^\\top\\mathbf{V}^{-1}\\mathbf{X}\\right)]^{\\frac{1}{k}}\\) where \\(k\\) is the number of parameter\n\n\nE-optimality\nmaximise the minimum eigenvalue of \\(\\mathbf{X}^\\top\\mathbf{V}^{-1}\\mathbf{X}\\)\n\n\n\n\nThe most popular optimal-criterions are A- and D-optimality.\n\n\n\n\n\n\nOptimised designs are not necessary randomised\n\n\n\nThis means that even if the design has been constructed as to optimise some criteria, you are possibly missing out on the benefits of the randomisation. Some experimental structure results in a multiple possible treatment allocations with the same optimal criteria and the software may be selecting this in a systematic way.\n\n\n\n\n\n\n\n\nOptimised designs for complex experiments\n\n\n\nOptimised designs for complex experiments can be computationally expensive. In these cases, the algorithm may be searching heuristically. You should try searching under different starting values and compare the optimal criteria obtained.\n\n\n\n\n1.2.3 Bias and confounding\nBiases can lurk into an experiment in many forms.\n\n\n\n\n\n\nExamples of biases\n\n\n\n\nTo test the effectiveness of flu vaccines, a trial for vaccine 1 is done in January and a trial for vaccine 2 is done in July.\nTo study the effects of different diets for pigs, diet A is given to the first set of pigs that the farmer caught and the remaining (faster) pigs received diet B.\nA doctor decides to assign the treatment to the sickest patients while the control treatment is assigned to the healthiest patients.\n\n\n\nBiases are not necessary introduced into the study with malicious or known intent (e.g. trying to ensure certain treatments have a better outcome by manipulating the treatment assignment). The third example is a case where the intention of the doctor is well but is introducing a selection bias.\nBias is counteracted generally by employing randomisation in the design.\nConfounding, which may or may not be the result of a bias, is when the factors in the design are highly correlated which makes it hard to distinguish which factor influenced the outcome with certainty. If an experimental factor of interest is confounded with some other factor, whether that be latent or not, then you do need to redo your experiment removing or adjusting this confounding.\n\n\n\n\n\n\nAll experiments are confounded and some confounding are okay\n\n\n\nIn essence, all experiments are confounded. In an unstructured experiment, the units are confounded with treatment – even with enough replications, you can only distinguish the effects if the response is an additive model of contributions from the treatment and the individual, otherwise there’s little value you will get from this experiment.\nSome confounding are acceptable. For example, in a randomised block experiment, different technicians may be assigned to each block. This will confound the effects of blocks and effects of technicians, but so long as these effects can be disaggregated from noise and the treatment effects, it’s not of a high concern to delineate the individual contributions from blocks and technicians.\n\n\n\n\n1.2.4 Replications, repetition and duplication\nIn a comparative experiment, treatments are allocated to units but every unit has an individual variation (with exceptions for some, e.g. computer experiments). To distinguish the individual variation from the treatment variation, you need replication of the treatment allocation to another independent unit.\nAs a simple example, consider Figure 1.1 – 2 treatments are allocated to 3 participants each. If you ever only look at the outcome of a single replication in isolation, you wouldn’t know whether the outcome is a result of the treatment the participant received or some innate biological attribute of the participant, thus nothing to do with the treatment. Only by replicating and getting similar results with other sets of participants can you start to feel confident that the outcome may be associated with the treatment.\n\n\n\n\n\nFigure 1.1: A comparative experiment with two treatments allocated to six participants. Each treatment is replicated thrice with the same outcome for the same treatment.\n\n\n\n\nSuppose now that in Figure 1.1, participants in Replicate 3 are biological sisters of participants in Replicate 1. In this case, Replicate 3 is not a complete replicate. As biological sisters, they would share genetics (and perhaps the environment) that makes it harder to feel confident that the outcome is due to treatment instead of other shared factors between the participants.\n\n\n\n\n\n\nCommon phrases for replication\n\n\n\nWhen we say:\n\n“no replication”, this is equivalent to one replication,\n“a [particular treatment level] is replicated” then it means that the treatment level has two or more replications,\n“unreplicated experiment” means that the experiment has no replication,\n“partial replication” means that a proportion of the treatments are replicated.\n\n\n\n\n\n\n\n\n\nPartially replicated experiment\n\n\n\nConsider an experiment with two treatments with two replicates for the first treatment and one replicate for the second treatment. This is a partially replicated (or \\(p\\)-rep) experiment and proportion replicated (\\(p\\)) is 0.5.\n\n\nA distinction must be made about replication, repetition and duplication. Replication refers to the allocation of same treatment to independent units. Repetition refers to the allocation of same treatment to another unit, which may or may not be independent. Duplication refers to repeated measurement of the same unit. This distinction often cannot be made just looking at the experimental data.\n\n\n\n\nA dummy experimental data. Is the treatment replicated here?\n \n  \n    block \n    unit \n    trt \n    response \n  \n \n\n  \n    1 \n    1 \n    A \n    10.1 \n  \n  \n    2 \n    2 \n    A \n    9.8 \n  \n  \n    3 \n    3 \n    B \n    8.8 \n  \n  \n    1 \n    4 \n    B \n    8.8 \n  \n  \n    2 \n    5 \n    C \n    7.4 \n  \n  \n    3 \n    6 \n    C \n    7.5 \n  \n\n\n\n\n\n\n1.2.4.1 How many replications?\nWhere treatments are independent (see Section X on correlated treatments), then it’s optimal to have equal, or near-equal, number of replications for each treatment.\nA related question to the number of replications is sample size calculation. Sample size calculation generally requires users to pre-specify a number of parameters, e.g. statistical power and expected effect size (or its difference).\nLarger sample size (and thus the number of replications) is always statistically desired for higher certainty in the analysis, but practical constraints will always counteract this. Avoid designing an unreplicated experiment. It’s better to have some replication, even if it’s only one more.\nAbove are statistical perspectives for the desired number of replications. In practice, the number of replications are also determined by non-statistical reasons. E.g., there are only limited number of treatments in stock; not enough subjects that qualify for treatments, time constraints and so on.\n\n\n\n\n\n\nPseudo-replications\n\n\n\nPseudo-replication refers to the analysis where repetitions of the treatment are treated as replications.\n\n\n\n\n\n1.2.5 Blocking\nBlocks are factors that group units that are alike together. Some units have natural discrete divisions, e.g. sex for animals, that should be used for blocking. Some units differ in qualities on a continuous scale (e.g. age, weight, space, time) and artificial thresholds may be chosen to group these units.\n\n\n\n\n\n\nHow to assign units to blocks\n\n\n\nWhere possible, it is better to have blocks of equal or near-equal size. Also where possible, it is better to have at least one occurence of each treatment in every block. This is of course not possible if the block size is smaller than the number of treatments – in this case, it is desirable to have every pair of treatments appear equal or near-equal times across blocks."
  },
  {
    "objectID": "basics.html#choosing-factors",
    "href": "basics.html#choosing-factors",
    "title": "1  Basics",
    "section": "1.3 Choosing factors",
    "text": "1.3 Choosing factors\n\n1.3.1 Choices of units\n\n\n1.3.2 Choices of treatments\nThe choice of treatments must be guided by the domain expert, however in some cases this may be guided by statistics. These generally include treatments that can be encoded as a numerical value, such as in dose finding experiments or Latin hyper cube sampling. In dose finding experiment, small-scale screening experiments may be done first to determine the dose levels for the larger trial. For Latin hyper cube sampling, several factors that have a continuous range and the level is sampled in a way that maximises a certain criterion.\nThe effectiveness of any treatment is only established in relation to another treatment, e.g. the control. As an analogy, consider a student that has been heralded as a mathematical genius because she has been getting perfect scores in all her assessments. But if you find out that all the other students in her class has been getting perfect scores as well, then you may rescind calling her a mathematical genius. The thing is though, all the students could indeed be mathematical geniuses but without comparisons with typical mathematics students, you will not be sure. Wrong comparisons could also be made, e.g. comparing the student with a member of general public, who does not practice mathematics day-to-day, leads to a logical fallacy of student appearing to excel in mathematics, when in fact it would be expected she would be better at mathematics than those who don’t make regular use of it.\n\n\n\n\n\n\nChoice of control treatment\n\n\n\nThe control treatment should be chosen such that the comparison is meaningful. For example, a new cancer treatment shouldn’t be compared to “no treatment” but to the standard approach to treat cancer. Not only may it be unethical to assign a “no treatment” to a cancer patient, it is wasteful of experimental resources to design experiments where there there is little interest in comparing to “no treatment”.\n\n\n\n\n1.3.3 Choices of data to record"
  },
  {
    "objectID": "basics.html#diagnosis",
    "href": "basics.html#diagnosis",
    "title": "1  Basics",
    "section": "1.4 Diagnosis",
    "text": "1.4 Diagnosis\nThis section addresses the statistical diagnosis of an experimental design. In addition, there are non-statistical diagnosis that should be made by the domain experts.\n\n1.4.1 Design anatomy\nThe design anatomy, or sometimes referred to as skeleton anova, shows the decomposition of the degrees of freedom for different sources of variation. This is important in finding out if there are any terms that are aliasing (i.e. perfectly confounded) or have low information.\n\n\n1.4.2 Diagrams\n\n\n1.4.3 Simulate\nIt’s good practice to simulate the data for the given design and try fitting the model in the analysis plan. This can help reflect about your design and also reveal any issues with fitting the planned model. You may plan for some complex model, however keep in mind that it doesn’t mean you can fit that model since you may be hit with issues like where model fails to converge and memory or speed issues with big data."
  },
  {
    "objectID": "basics.html#analysis",
    "href": "basics.html#analysis",
    "title": "1  Basics",
    "section": "1.5 Analysis",
    "text": "1.5 Analysis\nBefore starting the experiment, it is important to have an analysis plan of the experimental data.\n\n1.5.1 To include or not include blocking factors in your model?\nThe general consensus from the experimental design community is that you should include blocking factors in your model, regardless of whether the effect is significant or not, if the blocking factors were used to generate the experimental design. Some argue that if your aim is prediction, then it is better to remove the insignificant block effects.\nMy recommendation is that all factors used to generate the design should be used in your analysis model. If some blocking factors prove to be insignificant, then check to see how your analysis changes if you remove them."
  },
  {
    "objectID": "basics.html#data-collection-issues",
    "href": "basics.html#data-collection-issues",
    "title": "1  Basics",
    "section": "1.6 Data collection issues",
    "text": "1.6 Data collection issues\nRecognising potential data collection issues at the experimental design stage can be helpful in ensuring that there are sufficient and accurate data at the analysis stage. Some situations that can arise are:\n\nmissing data,\nchange in instrument to measure response,\nloss of data integrity (i.e. issues related to record, storage and access of data), and/or\nnon-compliance of experimental protocol.\n\nIn planning an experiment, it’s not prudent that the most statistical optimal design is produced. It is better to produce a design that technician can follow without great difficulty than produce a complex design that’s likely to result in a mistake in carrying it out."
  },
  {
    "objectID": "basics.html#ethics",
    "href": "basics.html#ethics",
    "title": "1  Basics",
    "section": "1.7 Ethics",
    "text": "1.7 Ethics\nWhile the aim of experiments may be to advance our knowledge or understanding, this doesn’t mean all experiments should be conducted. The Belmont report by the National Commission for the Proptection of Human Subjects of Biomedical and Behavioral Research (1978) outlines the ethical principles and guidelines for the protection of human subjects of research. A similar guideline would be available for animal subjects.\nBesides the protection of the subjects, the experiment should not go ahead if there is little possibility of extracting meaningful analysis. These include cases where the sample size is small so no conclusive evidence can be drawn from the experiment, or where the collected data does not answer the aim of the experiment."
  },
  {
    "objectID": "basics.html#protocol",
    "href": "basics.html#protocol",
    "title": "1  Basics",
    "section": "1.8 Protocol",
    "text": "1.8 Protocol\nSome domains require experimental protocol to be pre-registered."
  },
  {
    "objectID": "basics.html#summary",
    "href": "basics.html#summary",
    "title": "1  Basics",
    "section": "1.9 Summary",
    "text": "1.9 Summary\nThe major concepts this chapter covered are:\n\nbasic statistical terminology for experimental design\nimportance of replication and randomisation in experiments\npitfalls of pseudo-replication"
  },
  {
    "objectID": "basics.html#exercises",
    "href": "basics.html#exercises",
    "title": "1  Basics",
    "section": "1.10 Exercises",
    "text": "1.10 Exercises\n\nA farmer would like to know which diet is most effective in increasing the weight of the pigs. There are three types of diet that he wishes to test. For this scenario, describe the experimental aim, treatments, experimental units, observational units and the experimental design.\n\n\n\n\n\nBailey, Rosemary. 2008. Design of Comparative Experiments.\n\n\nFisher, Ronald. 1935. The Design of Experiments. Oliver; Boyd.\n\n\nNational Commission for the Proptection of Human Subjects of Biomedical and Behavioral Research. 1978. “The Belmont Report: Ethical Principles and Guidelines for the Protection of Human Subjects of Research.” Distributed by ERIC Clearinghouse."
  },
  {
    "objectID": "grammar.html",
    "href": "grammar.html",
    "title": "2  Grammar",
    "section": "",
    "text": "Grammar makes language expressive. A language consisting of words and no grammar (statement = word) expresses only as many ideas as there are words. By specifying how words are combined in statements, a grammar expands a language’s scope.\n– Wilkinson, 2005, The Grammar of Graphics, 2nd edition\nIn this chapter, I describe an object-oriented programming system called “the grammar of experimental designs” that is designed to capture elements of the origin of an experimental data encapsulated in a cognitive framework. The grammar of experimental designs is a term that is heavily influenced by Wilkinson (2005), who use the term “grammar of graphics” to describe an object-oriented system to create unlimited number of plots from following a relatively small number of rules. The grammar of graphics is adopted across many systems (Julia, Python, R, Tableau and so on) with its most popular interpretation (H. Wickham 2010) as the ggplot2 R-package (Hadley Wickham 2016). An overview of ggplot2 is given in Section 2.4. The grammar of experimental designs leverage aspects of the grammar of graphics for the visualisation of the experimental designs as discussed more extensively in Section 2.5.\nHenceforth, “grammar” refers to the grammar of experimental designs unless explicitly stated otherwise."
  },
  {
    "objectID": "grammar.html#fundamental-terminology",
    "href": "grammar.html#fundamental-terminology",
    "title": "2  Grammar",
    "section": "2.1 Fundamental terminology",
    "text": "2.1 Fundamental terminology\nSection 1.1 describe the basic terminology used in the field of experimental design. We can, however, describe some terms more fundamentally by considering every categorised entity (physical or otherwise) involved in the experiment to be a factor in the design. The two primary roles of a factor are treatments and units; under this categorisation blocks, experimental units and observational units are all just units – the explicit role of the unit is determined implicitly by the relationship of the factors. For example, if a treatment factor is allocated to a plot factor, then the plot is an experimental unit.\nIn the grammar, a factor is an experimental variable manifested as an object with a dual structure: the “head system” and the “root system”. The head system characterizes the holistic attributes of the factor (e.g. the label “vaccine” for the treatment factor) and the root system is the constitution of the discrete factor levels such that it captures the idiosyncratic semantic features of each level that distinguish itself from other levels (e.g. labels “type A” and “type B” for the two types of vaccine treatment). Every root and head system has an outer form that is visible to the user (usually in the form of a vertex or a vector) and an inner form that are intrinsic characteristics of the outer form (e.g. id of the levels, the long name of the vaccines, dose level of each vaccine, etc). A factor can be physical (e.g. person, plot, animal and drug), metaphysical (e.g. gender, time and space) or intended response measures. There are three types of information in the inner form: constant, common and specific. The constant inner form is the set of variables that cannot be directly modififed by the user; this is generally the IDs of the nodes. The common inner form is the set of variables that are common across all factors, e.g. label and class of the node. The specific inner form are variables that are set of variables that are specific to the factor – these are stored in a separate table. The inner form is not usually exported in the final design table. In the system, every root system co-exists with a head system in a reciprocal relationship, i.e. any change in the root structure may be reflected as a change in head structure (and vice-versa). A schema of the factor structure is shown in Figure 2.1.\n\n\n\nFigure 2.1: A schema for the factor structure in the grammar.\n\n\n\n\n\n\n\n\nPrinciple 1: Dual structure of factors\n\n\n\nAll factor must have a dual structure that describes the head (holistic attributes of the factor) and root (constitution of the levels).\n\n\nEvery factor in the system is given an explicit role stored as a class in the inner quality of the head. The main roles are unit, treatment and record. The relationship between factors assigns an implicit role, e.g. treatment linked as a directed graph to a unit as seen in Table 2.1.\n\n\nTable 2.1: Implicit role based on the relationship between factors\n\n\nA\nB\n\\(A \\rightarrow B\\) relationship\nImplicit role for B\n\n\n\n\nunit\nunit\nB is nested in A\nNested unit\n\n\ntreatment\nunit\nB is applied to A\nExperimental unit\n\n\nrecord\nunit\nB is measured on A\nObservational unit\n\n\n\n\nThere are two orders of relationships in the system: the higher-order links between the factor nodes in the head system and the lower-order links between the level nodes in the root system. A higher-order link is created by explicit specification by the user and depending on how it is defined, the system creates the lower-order links between the root nodes with some constraint as prescribed by their explicit role and other user inputs.\n\n\n\n\n\n\nPrinciple 2: Rules for relationships between factors\n\n\n\n\nA higher-order link between any two head nodes must be explicitly specified by the user.\nA lower-order link between any two root nodes cannot be made if there is no higher-order link between the head nodes linked to the two root nodes.\n\n\n\n\n\n\nFigure 2.2: An example network structure.\n\n\nIn the grammar, an intermediate construct of the experimental design is stored as an object that contain two types of directed graphs, \\(G_F = (V(G_F), E(G_F))\\) and \\(G_L = (V(G_L), E(G_L))\\), where \\(V(G_F)\\) and \\(V(G_L)\\) are sets of vertices and \\(E(G_F)\\) and \\(E(G_L)\\) are sets of edges. We refer \\(G_F\\) and \\(G_L\\) as factor graph and level graph, respectively. In the factor graph, every factor is represented as a single vertex. Every factor has a finite number of levels and each of these levels is represented as a single vertex in the level graph.\n\n\n\n\n\nA factor graph shows a high order view of the relationship between the factors in the experiment. In the above figure, there are two treatment factors: irrigation and fertilizer. Irrigation treatment is applied to the mainplot and the fertilizer treatment is applied to the subplot. The arrow from mainplot node to the subplot node implies that the subplot is nested in the mainplot. The shape and color of the node correspond to the class of the factor (e.g. unit, treatment).\n\n\n\n\n\n\n\nThe above figure shows the level graph. The nodes of the same color are the levels of the same factor (e.g. all yellow nodes correspond to the levels of the unit, subplot). The shape of the node correspond to the class of the corresponding factor.\n\n\n\n\n\n\n\n\nPrinciple 3: All factors must be given an identity\n\n\n\nAll nodes in the factor graph must be explicitly named.\n\n\nTable (tab:exam-table?) shows an example of an illustrative experiment that tests the exam score on a different exam time allocation for two different subjects. In such an experiment, the observational unit may be specified as the combination of Subject-Student, i.e. an observational unit can only be uniquely identified by using information across multiple factors. In the grammar, a factor cannot be implicitly assumed from other factors. This restriction means, for example, that a new factor, like Exam Booklet, which uniquely identifies every Subject-Student combination must be specified in the system. This restriction is not only for the purpose of internal graph representation but forces the user to confront what the observational units actually are. Naming things are hard, but without naming things, it can be hard to create a shared understanding about the experimental structure.\n\n\n\n\nThe table below shows the exam time allocation for every subject-student combination.\n \n  \n    Exam Booklet \n    Subject \n    Student \n    Exam Time \n    Score \n  \n \n\n  \n    1 \n    Math \n    1 \n    Morning \n    58 \n  \n  \n    2 \n    Science \n    1 \n    Afternoon \n    90 \n  \n  \n    3 \n    Math \n    2 \n    Afternoon \n    39 \n  \n  \n    4 \n    Science \n    2 \n    Morning \n    80 \n  \n\n\n\n\n\n\n\n\n\n\n\nPrinciple 4: All factor levels must map to a single observational unit\n\n\n\nA viable experimental design is only specified if the relationship between the factors can be reconciled to a single observational unit."
  },
  {
    "objectID": "grammar.html#an-edibble-graph",
    "href": "grammar.html#an-edibble-graph",
    "title": "2  Grammar",
    "section": "2.2 An edibble graph",
    "text": "2.2 An edibble graph\nAn edibble graph, or edbl_graph object, is a special type of directed graph. This form is used to represent intermediate constructs of the experimental design.\nIn a factor graph:\n\na vertex is a variable,\nan edge is a high-level connection between two variables, and\nthe direction of an edge defines a relationship based on which two variables it is connecting. Say if we have two nodes named A and B with a directed edge starting from A to B, then the meaning of the relationship follows from Table 2.1. If the combination is not listed below then the nodes cannot have a direct relationship.\n\nAs an example, consider a split-plot design that contains 4 main plots with 2 sub plots within each main plot (so 8 subplots in total). There are 2 treatment factors: fertilizer (with levels A and B) and variety (with levels V1 and V2). Each level of the fertilizer is randomly applied to two main plots. Each level of variety is randomly applied to one sub plot within each main plot. Two responses are planned to be measured on the sub plots: yield and height.\nIn a level graph:\n\na vertex is a level,\nan edge is a direct connection between two levels, and\nthe direction of an edge defines the same relationship as for high-level view, except if the edge is connecting nodes of levels of the same unit variable then it represents the sequence order of the levels.\n\nThe whole edibble graph object contains all the nodes and edges from the high- and low-level views. The whole edibble graph can have numerous nodes and edges, even when the number of units are small, that it’s visualisation will be too cluttered to be any useful. Consequently, when visualising these intermediate construct of the experimental design, only a high- or low-level view is visible to the user, but the object contains the information seen in both views."
  },
  {
    "objectID": "grammar.html#an-edibble-table-or-data-frame",
    "href": "grammar.html#an-edibble-table-or-data-frame",
    "title": "2  Grammar",
    "section": "2.3 An edibble table (or data frame)",
    "text": "2.3 An edibble table (or data frame)\nAn edibble, or edbl_table object, is a special class of tibble. The word “edibble” itself already implies that it is a table so appending the word with table or data frame seems superfluous. However, edibble can refer to the package, object, or used as an adjective to other objects, so appending edibble with table or data frame is to make explicit emphasis it refers to the edbl_table object, otherwise the reader is expected to infer its meaning by context.\nAn edbl_table was originally called edbl_df following convention from tibble but I decided to break away from this since other edibble components are graph and design, so a two letter word felt too short in contrast.\nAn edibble data frame is produced when the variables can be laid out in a tidy data format. An edibble is constructed from two possible ways:\n\nconverting edibble graph to edibble using serve_table and\nconverting existing data frame to edibble using edibble."
  },
  {
    "objectID": "grammar.html#sec-ggplot",
    "href": "grammar.html#sec-ggplot",
    "title": "2  Grammar",
    "section": "2.4 The (layered) grammar of graphics",
    "text": "2.4 The (layered) grammar of graphics"
  },
  {
    "objectID": "grammar.html#sec-deggust",
    "href": "grammar.html#sec-deggust",
    "title": "2  Grammar",
    "section": "2.5 Graphics for design of experiments",
    "text": "2.5 Graphics for design of experiments\n\n\n\n\nWickham, H. 2010. “A Layered Grammar of Graphics.” Journal of Computational and Graphical Statistics: A Joint Publication of American Statistical Association, Institute of Mathematical Statistics, Interface Foundation of North America.\n\n\nWickham, Hadley. 2016. Ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. https://ggplot2.tidyverse.org.\n\n\nWilkinson, Leland. 2005. The Grammar of Graphics. Springer."
  },
  {
    "objectID": "edibble.html",
    "href": "edibble.html",
    "title": "3  Getting started",
    "section": "",
    "text": "The experimental planning in this book is supported by the edibble R-package and its extensions. The edibble system is based on the grammar of experimental designs in Chapter 2. To get started with using the system, you need to first load the package:"
  },
  {
    "objectID": "edibble.html#setting-the-experimental-structure-and-context",
    "href": "edibble.html#setting-the-experimental-structure-and-context",
    "title": "3  Getting started",
    "section": "3.1 Setting the experimental structure and context",
    "text": "3.1 Setting the experimental structure and context\nIn the edibble system, an experiment design is built step-by-step. In the first step, you start with initialising the design by using the design() where the user can supply an optional title of the experiment. All subsequent steps are best specified after using the pipe operator (%>%) re-exported from the magrittr package or the native pipe operator (|>) available from R version 4.1 onwards. For example, below we carry out the following steps:\n\ninitiate an experiment called “My first experiment” via design();\nset 24 pots with set_units(); and then\nset treatments with 3 levels: 2 bacterial strains (PM398 and ZNP1) and no innoculation with set_trts().\n\n\nmydesign1 <- design(\"My first experiment\") %>% \n  set_units(pot = 24) %>% \n  set_trts(innoculation = c(\"PM398\", \"ZNP1\", \"none\"))\n\nThese steps create and modify a so-called “edibble design” (edbl_design) object that is used to represent an intermediate construct of an experimental design. The arguments in the functions set_units() and set_trts() employ the convention that the left hand side (LHS) is the name of the factor and the input on the right hand side (RHS) defines the levels. If the RHS is a single integer then it’s assumed to be the number of levels and if it’s a vector then it’s the name of the levels.\nThe print out of this object, as seen below, is displayed like a tree summarising the variables defined thus far.\n\nmydesign1\n\nMy first experiment\n├─pot (24 levels)\n└─innoculation (3 levels)\n\n\nIf you view the print out in the terminal or console, you will actually see that text are color coded so it’s easier to distinguish between the type of variables (e.g. unit or treatment). The above print out in a terminal will be viewed like below. These colors are customisable as discussed in Section @ref(aes-custom).\n\n\n\n\n\nThe argument names in set_units and set_trts are not fixed, so you could easily change the name of the units or treatment to something more meaningful. Below we have another experiment which has a statistically equivalent experimental structure as the previous experiment (24 units and 3 levels of treatment), but it “reads” as a different experimental context – a typical user will realise that the experimental units are pigs and treatments are diet.\n\nmydesign2 <- design(\"My second experiment\") %>% \n  set_units(pig = 24) %>% \n  set_trts(diet = c(\"high-fat\", \"low-fat\", \"standard\"))\n\nmydesign2\n\nMy second experiment\n├─pig (24 levels)\n└─diet (3 levels)\n\n\nYou can define more than one unit factor or treatment factor. For example below, it reads as that there are: 3 pens (named “North”, “Shade” and “Meadow”), 18 pigs, 3 type of diets and 2 types of supplement given at a frequency of either daily or weekly.\n\ndesign(\"My experiment with multiple factors\") %>% \n  set_units(pen = c(\"North\", \"Shade\", \"Meadow\"),\n            pig = 18) %>% \n  set_trts(diet = c(\"high-fat\", \"low-fat\", \"standard\"),\n           supplement = 2, \n           # frequency of supplements:\n           frequency = c(\"daily\", \"weekly\"))\n\nMy experiment with multiple factors\n├─pen (3 levels)\n├─pig (18 levels)\n├─diet (3 levels)\n├─supplement (2 levels)\n└─frequency (2 levels)\n\n\nThe unit and treatment factors do not need to be defined in one call. The ordering of the functions is commutative where the factor is not dependent directly on another factor.\n\ndesign(\"My experiment with multiple factors\") %>% \n  set_units(pen = c(\"North\", \"Shade\", \"Meadow\")) %>%\n  set_trts(diet = c(\"high-fat\", \"low-fat\", \"standard\"),\n           supplement = 2) %>% \n  # frequency of supplements\n  set_trts(frequency = c(\"daily\", \"weekly\")) %>% \n  set_units(pig = 18) \n\nMy experiment with multiple factors\n├─pen (3 levels)\n├─diet (3 levels)\n├─supplement (2 levels)\n├─frequency (2 levels)\n└─pig (18 levels)\n\n\n\n3.1.1 A viable experimental design\n\n\n\n\n\n\nA viable experimental design is only specified if the relationship between the variables can be reconciled to a single observational unit.\n\n\n\nFor example below\n\ndesign(\"An invalid unit structure\") %>% \n  set_units(pen = 6,\n            pig = 18) %>% \n  serve_table()\n\n# An invalid unit structure \n# An edibble: 0 x 2\n# … with 2 variables: pen <unit(6)>, pig <unit(18)>\n\n\n\n\n3.1.2 Understanding the experimental context\n\n\n3.1.3 Fitting a variety of mental mode"
  },
  {
    "objectID": "edibble.html#map-trts",
    "href": "edibble.html#map-trts",
    "title": "3  Getting started",
    "section": "3.2 Mapping treatment to units",
    "text": "3.2 Mapping treatment to units\nThe above code creates an object that represents an intermediate construct of an experimental design. To complete the specification of a minimum experimental design, we still need to specify:\n\nthe mapping of the treatments to units, which is achieved using allot_trts(), and\nhow the treatments are actually allocated to units via assign_trts().\n\nThese step may feel redundant in experiments where there is exactly one unit factor and one treatment factor but it’s required for further generalisation to other experimental structures. In addition, it serves to re-enforce the specific actions to the user.\n\ndes <- design(\"My first animal experiment\") %>% \n  set_units(pig = 24) %>% \n  set_trts(diet = c(\"high-fat\", \"low-fat\", \"standard\")) %>% \n  allot_trts(diet ~ pig) %>% \n  assign_trts(order = \"random\", seed = 1) \n\nOnce a minimum viable experimental design has been specified, then you can generate the experimental design table (or tibble) called edibble by parsing the object to serve_table().\n\nserve_table(des)\n\n# My first animal experiment \n# An edibble: 24 x 2\n          pig     diet\n   <unit(24)> <trt(3)>\n 1      pig1  high-fat\n 2      pig2  low-fat \n 3      pig3  standard\n 4      pig4  high-fat\n 5      pig5  low-fat \n 6      pig6  standard\n 7      pig7  standard\n 8      pig8  high-fat\n 9      pig9  low-fat \n10      pig10 low-fat \n# … with 14 more rows\n\n\n\n3.2.1 Treatment allotment\n\ndiet_design <- function(...) {\n  design(\"A valid nested design\") %>% \n    set_units(pen = 6,\n              pig = nested_in(pen, 3)) %>% \n    set_trts(diet = c(\"high-fat\", \"low-fat\", \"standard\")) %>% \n    allot_trts(...) %>% \n    assign_trts(order = \"systematic\") %>% \n    serve_table()\n}\n\ndiet_design(diet ~ pig)\n\n# A valid nested design \n# An edibble: 18 x 3\n         pen        pig     diet\n   <unit(6)> <unit(18)> <trt(3)>\n 1      pen1      pig1  high-fat\n 2      pen1      pig2  low-fat \n 3      pen1      pig3  standard\n 4      pen2      pig4  high-fat\n 5      pen2      pig5  low-fat \n 6      pen2      pig6  standard\n 7      pen3      pig7  high-fat\n 8      pen3      pig8  low-fat \n 9      pen3      pig9  standard\n10      pen4      pig10 high-fat\n11      pen4      pig11 low-fat \n12      pen4      pig12 standard\n13      pen5      pig13 high-fat\n14      pen5      pig14 low-fat \n15      pen5      pig15 standard\n16      pen6      pig16 high-fat\n17      pen6      pig17 low-fat \n18      pen6      pig18 standard\n\n\n\ndiet_design(diet ~ pen)\n\n# A valid nested design \n# An edibble: 18 x 3\n         pen        pig     diet\n   <unit(6)> <unit(18)> <trt(3)>\n 1      pen1      pig1  high-fat\n 2      pen1      pig2  high-fat\n 3      pen1      pig3  high-fat\n 4      pen2      pig4  low-fat \n 5      pen2      pig5  low-fat \n 6      pen2      pig6  low-fat \n 7      pen3      pig7  standard\n 8      pen3      pig8  standard\n 9      pen3      pig9  standard\n10      pen4      pig10 high-fat\n11      pen4      pig11 high-fat\n12      pen4      pig12 high-fat\n13      pen5      pig13 low-fat \n14      pen5      pig14 low-fat \n15      pen5      pig15 low-fat \n16      pen6      pig16 standard\n17      pen6      pig17 standard\n18      pen6      pig18 standard"
  },
  {
    "objectID": "edibble.html#setting-records-with-expectations",
    "href": "edibble.html#setting-records-with-expectations",
    "title": "3  Getting started",
    "section": "3.3 Setting records with expectations",
    "text": "3.3 Setting records with expectations\nThe term “records”, often abbreviated as rcrd in the edibble system, refers to any observational variables, including response variables. Setting records is a way to describe the intent of the observations that you will collect in the experiment. All records must be made on a unit. The primary way to set the record is using set_rcrds() where the LHS is the factor name of the record and the RHS is the unit factor on which the record will be measured. The LHS of the input in set_rcrds() follow the same pattern as set_units() and set_trts() as the LHS is the name of the new factor. In the example below, we are measuring weight and sex of the pig and recording the manager of each pen. In this example there are only 6 pens, therefore there should be only a maximum of 6 managers recorded.\n\ndesr <- diet_design(diet ~ pen) %>% \n  set_rcrds(weight = pig,\n            sex = pig,\n            manager = pen) \n\ndesr\n\n# A valid nested design \n# An edibble: 18 x 6\n         pen        pig     diet weight    sex manager\n   <unit(6)> <unit(18)> <trt(3)> <rcrd> <rcrd>  <rcrd>\n 1      pen1      pig1  high-fat      ■      ■       ■\n 2      pen1      pig2  high-fat      ■      ■       x\n 3      pen1      pig3  high-fat      ■      ■       x\n 4      pen2      pig4  low-fat       ■      ■       ■\n 5      pen2      pig5  low-fat       ■      ■       x\n 6      pen2      pig6  low-fat       ■      ■       x\n 7      pen3      pig7  standard      ■      ■       ■\n 8      pen3      pig8  standard      ■      ■       x\n 9      pen3      pig9  standard      ■      ■       x\n10      pen4      pig10 high-fat      ■      ■       ■\n11      pen4      pig11 high-fat      ■      ■       x\n12      pen4      pig12 high-fat      ■      ■       x\n13      pen5      pig13 low-fat       ■      ■       ■\n14      pen5      pig14 low-fat       ■      ■       x\n15      pen5      pig15 low-fat       ■      ■       x\n16      pen6      pig16 standard      ■      ■       ■\n17      pen6      pig17 standard      ■      ■       x\n18      pen6      pig18 standard      ■      ■       x\n\n\nAnother equivalent way to set the record is using set_rcrds_of(). The format of the input is such that the unit factors are on the LHS and the RHS are character vectors of new record factor names. The reason that names are set as characters is because the factors in the RHS do not yet exist. In contrast, the RHS of the input in set_rcrds() is unquoted because those factors exist. The suffix _of in the function name is purposely chosen to signal that the pattern for the LHS no longer follows that of set_rcrds(), set_trts() and set_units() where the LHS is always a new factor name.\n\ndiet_design(diet ~ pen) %>% \n  set_rcrds_of(pig = c(\"weight\", \"sex\"),\n               pen = \"manager\")\n\nYou may choose to also set expecations of the record. For example, we assert below that the weight of a grown pig must be a minimum of 15 kg.\n\ndesre <- desr %>% \n  expect_rcrds(weight > 15,\n               factor(sex, levels = c(\"F\", \"M\")))\n\nYou might see that it is good principles to be explicit about the records but you may not feel motivated for such verbose coding. There are downstream benefits for this as explained in Sections @ref(simulate) and @ref(export)."
  },
  {
    "objectID": "edibble.html#simulate",
    "href": "edibble.html#simulate",
    "title": "3  Getting started",
    "section": "3.4 Simulating records",
    "text": "3.4 Simulating records\n\ndat <- desre %>% \n  simulate_rcrds(weight = sim_normal(~diet + pen + pig, sd = 25) %>% \n                   params(\"mean\", \n                          diet = c(\"high-fat\" = 300,\n                                    \"low-fat\" = 50,\n                                   \"standard\" = 150),\n                          pen = c(\"pen4\" = -270),\n                          pig = rnorm(18)),\n                 manager = sim_form(~pen) %>% \n                   params(pen = sample(rep(c(\"John\", \"Mary\", \"Jane\"), 2))),\n                 .seed = 1, .censor = NA)\n\ndat\n\n# A valid nested design \n# An edibble: 18 x 6\n         pen        pig     diet weight    sex manager\n   <unit(6)> <unit(18)> <trt(3)>  <dbl> <rcrd> <chr>  \n 1      pen1      pig1  high-fat  319.       ■ John   \n 2      pen1      pig2  high-fat  302.       ■ John   \n 3      pen1      pig3  high-fat  249.       ■ John   \n 4      pen2      pig4  low-fat    67.1      ■ Jane   \n 5      pen2      pig5  low-fat    48.9      ■ Jane   \n 6      pen2      pig6  low-fat    45.3      ■ Jane   \n 7      pen3      pig7  standard  114.       ■ Mary   \n 8      pen3      pig8  standard  139.       ■ Mary   \n 9      pen3      pig9  standard  161.       ■ Mary   \n10      pen4      pig10 high-fat   63.7      ■ Jane   \n11      pen4      pig11 high-fat   28.9      ■ Jane   \n12      pen4      pig12 high-fat   40.1      ■ Jane   \n13      pen5      pig13 low-fat    48.0      ■ Mary   \n14      pen5      pig14 low-fat    NA        ■ Mary   \n15      pen5      pig15 low-fat    40.8      ■ Mary   \n16      pen6      pig16 standard  140.       ■ John   \n17      pen6      pig17 standard  149.       ■ John   \n18      pen6      pig18 standard  178.       ■ John   \n\n\n\nggplot(dat, aes(pen, weight, color = diet)) + \n  geom_point(size = 3) \n\nWarning: Removed 1 rows containing missing values (geom_point)."
  },
  {
    "objectID": "edibble.html#export",
    "href": "edibble.html#export",
    "title": "3  Getting started",
    "section": "3.5 Exporting the design",
    "text": "3.5 Exporting the design"
  },
  {
    "objectID": "edibble.html#aes-custom",
    "href": "edibble.html#aes-custom",
    "title": "3  Getting started",
    "section": "3.6 Aesthetic customisations",
    "text": "3.6 Aesthetic customisations\nThe edibble system offers you many levels of aesthetic customisations. These customisation are mostly frivolous and serve as means for users to customise elements visually to their liking. The level of aethetic customisation in the edibble system is probably of little value in the grand aim of constructing an experimental design, but if a user finds the developer’s default choice is not to their liking, at least they have the ability to modify it."
  },
  {
    "objectID": "edibble.html#visualisation",
    "href": "edibble.html#visualisation",
    "title": "3  Getting started",
    "section": "3.7 Visualisation",
    "text": "3.7 Visualisation\n\nlibrary(deggust)"
  },
  {
    "objectID": "edibble.html#examples",
    "href": "edibble.html#examples",
    "title": "3  Getting started",
    "section": "3.8 Examples",
    "text": "3.8 Examples\n\n\n\n\n\n\nBailey (2008) Exercise 8.5\nIn a biotechnology experiment, plants were grown in 90 pots. Five different quantities of potassium were randomized to the pots, so that each quantity was applied to the soil in 18 pots. After each of 15, 30 and 45 days, one plant was randomly chosen from each pot and removed; nine small pieces were cut from it to be used for tissue culture. Three different levels of nutrition were each applied to three of the pieces of each plant removed at each time. After a certain further length of time, the number of plantlets growing in each piece of tissue was counted.\n\n\n\n\ndesign(\"Bailey (2008) Exercise 8.5\") %>% \n  set_units(pot = 90,\n            plant = nested_in(pot, 3),\n            piece = nested_in(plant, 9)) %>% \n  set_trts(pottasium = c(\"q1\", \"q2\", \"q3\", \"q4\", \"q5\"), \n           nutrition = 3) %>% \n  allot_trts(pottasium ~ pot,\n             nutrition ~ piece) %>% \n  assign_trts() %>% \n  set_rcrds(plantlets = piece) %>% \n  serve_table()\n\n# Bailey (2008) Exercise 8.5 \n# An edibble: 2,430 x 6\n          pot       plant      piece pottasium  nutrition plantlets\n   <unit(90)> <unit(270)> <unit(2k)>  <trt(5)>   <trt(3)>    <rcrd>\n 1       pot1      plant1    piece1         q2 nutrition1         ■\n 2       pot1      plant1    piece2         q2 nutrition3         ■\n 3       pot1      plant1    piece3         q2 nutrition3         ■\n 4       pot1      plant1    piece4         q2 nutrition1         ■\n 5       pot1      plant1    piece5         q2 nutrition2         ■\n 6       pot1      plant1    piece6         q2 nutrition2         ■\n 7       pot1      plant1    piece7         q2 nutrition2         ■\n 8       pot1      plant1    piece8         q2 nutrition3         ■\n 9       pot1      plant1    piece9         q2 nutrition1         ■\n10       pot1      plant2    piece10        q2 nutrition1         ■\n# … with 2,420 more rows\n\n\n\n\n\n\n\n\nBailey (2008) Exercise 9.6\nA horticultural research station intends to investigate the effects of two treatment factors on the total weight of apples produced from apple trees. One treatment factor is the method of thinning; that is, removing fruitlets at an early stage of development so that those remaining will be able to grow larger. There are five methods of thinning, coded as A,B,C,D,E. The second treatment factor is the type of grass to grow around the base of the tree to prevent the growth of weeds. There are five types of grass, coded as a,b,c,d,e. It is assumed that there is no interaction between method of thinning and type of grass. There are 25 trees available for the experiment. They are arranged in a 5×5 rectangle. Construct a suitable design.\n\n\n\n\ndf <- design(\"Bailey (2008) Exercise 9.6\") %>% \n  set_trts(thinning = c(\"A\", \"B\", \"C\", \"D\", \"E\"),\n           grass = c(\"a\", \"b\", \"c\", \"d\", \"e\")) %>% \n  set_units(row = 5,\n            col = 5,\n            tree = crossed_by(row, col)) %>% \n  set_rcrds(apple_weight_total = tree) %>% \n  allot_table(thinning ~ tree,\n              grass ~ tree)\n\nanatomy(df)\n\n\n\nSummary table of the decomposition for unit & trt (based on adjusted quantities)\n\n Source.unit df1 Source.trt     df2 aefficiency eefficiency order\n row           4 thinning#grass   4      0.5625      0.5000     2\n col           4 thinning#grass   4      0.5625      0.5000     2\n tree         16 thinning         4      1.0000      1.0000     1\n                 grass            4      1.0000      1.0000     1\n                 thinning#grass   8      0.2500      0.1000     2\n\nTable of information (partially) aliased with previous sources derived from the same formula\n\n Source df Alias                    In  aefficiency eefficiency order\n grass  1  thinning                 trt      0.6400      0.6400     1\n grass  4  ## Information remaining trt      0.6923      0.3600     2\n\nThe design is not orthogonal\n\nautoplot(df)\n\n\n\n\n\n\n\n\n\n\nBailey (2008) Exercise 9.6\nA road safety organization wishes to compare four makes of car tyre. The organization has four test cars and four test drivers. One working day is needed to fit new tyres to a car, take it for an exhaustive test-drive, take relevant measurements on tyre treads, record all details of the test-drive, and prepare the car for the next session. The organization has only one week in which to perform its tests. To keep each car properly balanced, the organization has decided that all four tyres on a car at any one time should be of the same make. Construct a suitable design for this trial.\n\n\n\n\ndf <- design(\"Tyre test\") %>%\n  set_units(car = 4,\n            driver = 4,\n            day = 5,\n            test_drive = crossed_by(day, car, driver),\n            #tyre = nested_in(test_drive, 4)\n            ) %>% \n  set_trts(make = 4) %>% \n  #set_rcrds(measure = tyre) %>% \n  allot_table(make ~ test_drive)\n\nanatomy(df)\n\n\n\nSummary table of the decomposition for unit & trt\n\n Source.unit df1 Source.trt df2 aefficiency eefficiency order\n car           3                                             \n driver        3                                             \n day           4                                             \n test_drive   69 make         3      1.0000      1.0000     1\n                 Residual    66                              \n\nautoplot(df)\n\n\n\n\n\n\n\n\n\n\nBailey (2008) Example 10.19\nA manufacturer of household appliances wants to find the best combination of wash temperature and drying temperature to produce unwrinkled cotton sheets at the end of the laundry session. He wants to compare four different wash temperatures and three different drying temperatures. He uses eight similar washing machines and six similar dryers. First, 48 cotton sheets are randomly allocated to the washing machines, six per machine. The wash temperatures are randomly allocated to the washing machines so that two machines are run at each temperature. After the wash, the six sheets in each machine are randomly allocated to the dryers, one per dryer. Then the drying temperatures are randomly allocated to the dryers so that two machines are run at each temperature. After the drying, all 48 sheets are scored by experts for how wrinkled they are.\n\n\n\n\ndf <- design(\"Bailey (2008) Example 10.19\") %>%\n  set_trts(wash_temp = 4,\n           dry_temp = 3) %>% \n  set_units(washer = 8,\n            dryer = 6,\n            sheet = 48) %>% \n  allot_units(washer ~ sheet,\n              dryer ~ washer/sheet) %>% \n  allot_trts(wash_temp ~ washer,\n              dry_temp ~ dryer) %>% \n  assign_trts(\"random\") %>% \n  assign_units(\"random\") %>% \n  set_rcrds(score = sheet) %>% \n  serve_table()\n\nanatomy(df)\n\n\n\nSummary table of the decomposition for unit & trt\n\n Source.unit df1 Source.trt         df2 aefficiency eefficiency order\n washer        7 wash_temp            3      1.0000      1.0000     1\n                 Residual             4                              \n dryer         5 dry_temp             2      1.0000      1.0000     1\n                 Residual             3                              \n sheet        35 wash_temp#dry_temp   6      1.0000      1.0000     1\n                 Residual            29                              \n\nautoplot(df)\n\n\n\n\n\n\n\n\n\n\nBailey (2008) Example 10.20\nAn agronomy institute in Brazil conducted a factorial experiment on beans. The treatment factors were cultivar (there were three cultivars), seeding (either conventional or with no tillage), and molybdenum (either applied or not). The experimental area was divided into four blocks. Each block was a 3×4 rectangle. The three rows were called strips; cultivars were applied to these. The four columns, which were called quarters, were grouped into two halves. The different seeding methods were used in the two halves of each block, and the Mo (molybdenum) was applied to one quarter in each half.\n\n\n\n\ndf <- design(\"Bailey (2008) Example 10.20\") %>% \n  set_trts(cultivar = 3,\n           seeding = c(\"conventional\", \"no tillage\"),\n           molybdenum = c(\"applied\", \"none\")) %>% \n  set_units(block = 4,\n            strip = nested_in(block, 3),\n            half = nested_in(block, 2),\n            quarter = nested_in(half, 2),\n            plot = nested_in(block, crossed_by(strip, quarter))) %>% \n  allot_table(cultivar ~ strip,\n              seeding ~ half,\n              molybdenum ~ quarter) \n\ndf\n\n# Bailey (2008) Example 10.20 \n# An edibble: 48 x 8\n    cultivar      seeding molybdenum     block      strip      half\n    <trt(3)>     <trt(2)>   <trt(2)> <unit(4)> <unit(12)> <unit(8)>\n 1 cultivar2 conventional    none       block1     strip1     half1\n 2 cultivar1 conventional    none       block1     strip2     half1\n 3 cultivar3 conventional    none       block1     strip3     half1\n 4 cultivar2 conventional    applied    block1     strip1     half1\n 5 cultivar1 conventional    applied    block1     strip2     half1\n 6 cultivar3 conventional    applied    block1     strip3     half1\n 7 cultivar2 no tillage      none       block1     strip1     half2\n 8 cultivar1 no tillage      none       block1     strip2     half2\n 9 cultivar3 no tillage      none       block1     strip3     half2\n10 cultivar2 no tillage      applied    block1     strip1     half2\n# … with 38 more rows, and 2 more variables: quarter <unit(16)>,\n#   plot <unit(48)>\n\nanatomy(df)\n\nWarning in pstructure.formula(formulae[[1]], keep.order = keep.order, grandMean\n= grandMean, : block:half is aliased with previous terms in the formula and has\nbeen removed\n\n\n\n\nSummary table of the decomposition for unit & trt (based on adjusted quantities)\n\n Source.unit         df1 Source.trt                  df2 aefficiency\n block                 3                                            \n half[block]           4 seeding                       1      1.0000\n                         Residual                      3            \n strip[block]          8 cultivar                      2      1.0000\n                         Residual                      6            \n quarter[block:half]   8 molybdenum                    1      1.0000\n                         seeding#molybdenum            1      1.0000\n                         Residual                      6            \n plot[block]          24 cultivar#seeding              2      1.0000\n                         cultivar#molybdenum           2      1.0000\n                         cultivar#seeding#molybdenum   2      1.0000\n                         Residual                     18            \n eefficiency order\n                  \n      1.0000     1\n                  \n      1.0000     1\n                  \n      1.0000     1\n      1.0000     1\n                  \n      1.0000     1\n      1.0000     1\n      1.0000     1\n                  \n\nTable of information (partially) aliased with previous sources derived from the same formula\n\n Source      df Alias       In   aefficiency eefficiency order\n half[block] 4  half[block] unit      1.0000      1.0000     1\n half[block] 0  ## Aliased  unit      1.0000      1.0000     1\n\n\n\n\n\n\n\n\nBailey (2008) Exercise 10.5\nIn an experiment into the digestibility of stubble, four feed treatments are to be applied to sheep. There are 16 sheep, in four rooms of four animals each. There are four test periods of four weeks each, separated by two-week recovery periods. Each sheep is to be fed all treatments, one in each test period. During the recovery periods all animals will receive their usual feed, so that they will return to normal conditions before being subjected to a new treatment.\n\n\n\n\ndes <- design(\"Bailey (2008) Exercise 10.5\") %>% \n  set_trts(feed = 4) %>% \n  set_units(room = 4,\n            sheep = nested_in(room, 4),\n            period = 4,\n            unit = crossed_by(period, sheep)) %>% \n  allot_table(feed ~ unit)\n\n# anatomy(des)\nautoplot(des)\n\n\n\n\n\n\n\n\n\n\nBailey (2008) Exercise 10.6\nAn experiment was carried out to find out if so-called ‘non-herbicidal’ pesticides affect photosynthesis in plants. Six pesticides were compared: diuron, carbofuran, chlorpyrifos, tributyltin chloride, phorate and fonofos. Each of these was dissolved in water at five different concentrations. In addition, plain water was used as a control treatment. Two petri dishes were used for each treatment. Each petri dish was filled with pesticide solution or water. Five freshly cut leaves from mung beans were floated on the surface ofthe solution in each dish. After two hours, the chlorophyll fluorescence of each leaf was measured.\n\n\n\n\ndesign(\"Bailey (2008) Exercise 10.6\") %>% \n  set_trts(pesticide = c(\"diuron\", \"carbofuran\", \"chlorpyrifos\", \"tributyltin chloride\", \n                         \"phorate\", \"fonofos\"),\n           concentration = 5) %>% \n  add_trts(pesticide = \"none\", concentration = NA) %>% \n  set_units(petri = 2 * ntrts())\n\n\n# emylyn's design\nlibrary(edibble)\ndes1 <- design(\"sensory evaluation\") %>% \n  set_units(day = 4,\n            consumer = nested_in(day, 42)) %>% \n  set_trts(cover_story = c(\"yes\", \"no\"),\n           test_half = c(\"triangle\", \"paired\"),\n           test_first = c(\"triangle/paired\", \"monadic\")) %>% \n  allot_table(test_half:cover_story ~ day,\n                         test_first ~ consumer, \n              order = c(\"systematic\", \"random\"))\n\nlibrary(tidyverse)\n\ndes1 %>% \n    filter(test_half == \"triangle\") %>% \n    select(day, consumer) %>% \n    # do the next design\n    restart_design(\"triangle test\") %>% \n    set_units(day, consumer) %>% \n    allot_units(consumer ~ nested_in(day)) %>% \n    # finished described relationship - new design variables\n    edbl_design() %>% \n    set_units(test = nested_in(consumer, 2), \n              product = nested_in(test, 3)) %>% \n    set_trts(spiked = c(\"1/3\", \"2/3\"),\n             pattern = c(\"XXO\", \"XOX\", \"OXX\")) %>% \n    allot_table(spiked ~ test, \n                pattern ~ product)\n\n\n\n\n\nBailey, Rosemary. 2008. Design of Comparative Experiments."
  },
  {
    "objectID": "management.html",
    "href": "management.html",
    "title": "4  Project management",
    "section": "",
    "text": "An experiment generally involves more than one person. For simplicity, let us suppose there are four actors:\n\nthe domain expert who drives the experimental objective and has the intricate knowledge about the subject area,\nthe statistician who creates the experimental design layout after taking into account statistical and practical constraints,\n\nthe technician who carries out the experiment and collects the data, and\nthe analyst who analyses the data after the data are collected.\n\nThe actors are purely illustrative and in practice, multiple people can take on each role, one person can take on multiple roles, and a person is not necessary a specialist in the role assigned (e.g. a statistician role can be carried out by a person who’s primarily training is not in statistics). All the roles can be acted out by a single individual. Ideally, all parties should have clarity of the final experimental design.\nTo carry out this experiment, the people involved in the experiment must come to some degree of shared understanding about the experimental motivations, limitations and protocol. This understanding is achieved by communication. People may opt for a series of behavioural cycles that facilitate the process of clarification as they work to reduce uncertainty about their understanding.\n\n\n\n\n\nEach actor does not need to have a full comprehension of the experiment, but rather focus on the most pertinent part of the experiment that is relevant to their role. For example in the guinea pig experiment [add ref], a statistician does not need to know how the guinea pigs were sourced for the experiment – just that the subjects are genetically identical – in fact, a statistician can generate an experimental design without even knowledge that the subjects are guinea pigs. From the view point of the statistician, the experiment can be simplified to its bare essential elements to generate the experimental design. Why then would there be any need to encode the context of the experiment in generating the experimental design?\nThe minimum required understanding for a statistician to conduct their role does not include understanding the experimental context. This is the reason perhaps that a lot of computational systems to generate the experimental design have often the inputs stripped off the experimental context. In an idealistic world, this approach would be fine but the major problem in this process is that the involved parties most likely do not know what is the most relevant knowledge for a statistician."
  },
  {
    "objectID": "cookbook.html",
    "href": "cookbook.html",
    "title": "5  Cookbook",
    "section": "",
    "text": "Good design considers units and treatments first, and then allocates treatments to units. It does not choose from a menu of named designs.\n– Bailey, 2008, Design of Comparative experiments\nEvery experiment requires a tailored design to properly suit the situation; you shouldn’t simply select an experimental design from a list of named designs. This concept isn’t unique to just experimental designs; take architecture for example where near identical “cookie-cutter” homes get built on masses to make development cheaper but it comes at a detrimental cost when it’s not fit for the landscape. There’s an economical cost that perhaps drive the use of cookie-cutter homes, but what’s the cost of using carefully tailored experimental designs? That you have to think more about the experiment? It’s a small cost if you think about the consequences of an ill-designed experiment. And I’m no real estate expert, but I wouldn’t invest in a cheap home that’s cutting corners to the point that it may have defects.\nNamed experimental design are handy in succinctly describing the experimental structure and treatment allotment to units, but you lose the direct association to the fundamental components that make up the experimental design. This can obscure seeing the association between different named experimental designs. The idea of the fundamental system in edibble is to encourage higher-order thinking from the user.\nThe use of named experimental designs is an endemic – it will continue to be prevalent in the field. So a compromising approach is used in the edibble system. For every named experimental design presented, there will be a function prefixed by menu_ that shows the recipe code in terms of the fundamental system. The user is supposed to copy-and-paste these code and modify the names of the units and treatments to their experimental context. You can choose to generate a design table using takeout(), but again I discourage you to use these approaches to generate a proper design.\nThe following sections present a number of recipes for some well known named experimental designs. The ingredients for each recipe are described in fundamental system terms (see Section @ref(grammar))."
  },
  {
    "objectID": "cookbook.html#completely-randomised-design",
    "href": "cookbook.html#completely-randomised-design",
    "title": "5  Cookbook",
    "section": "5.1 Completely randomised design",
    "text": "5.1 Completely randomised design\nA completely randomised design, commonly abbreviated as CRD, contain two factors: experimental units and treatments with a completely unstructured experiment (i.e. no grouping for the factors). CRD is sufficiently characterised by the number of units, \\(n\\), and the number of treatment, \\(t\\). Instead of \\(n\\), you ccan parameterise the design with the number of replications, \\(r\\); in which case, you can derive \\(n = rt\\). The later parameterisation means that the design will be balanced while the former does not guarantee that the design is balanced.\nYou can call on menu_crd() to see the code in the terms of the fundamental system. If you omit the argument values, then a random parameterisation will be selected for you. You can find more details about the design in the documentation (?menu_crd).\n\nmenu_crd()\n\ndesign(\"Completely Randomised Design\") %>%\n  set_units(unit = 23) %>%\n  set_trts(trt = 10) %>%\n  allot_trts(trt ~ unit) %>%\n  assign_trts(\"random\", seed = 679) %>%\n  serve_table()\n\n\nIf you want to generate the design table, then you can use the takeout() function parsing the named design object created by the set of menu_ functions. If you don’t select any menu then the takeout() function will automatically select a random menu for you. You can find the list of available named experimental designs by calling on scan_menu(). For now, let’s “takeout” the completely randomised design with 5 treatments and 30 experimental units.\n\ncrd <- takeout(menu_crd(t = 5, n = 30, seed = 1), )\ncrd\n\ndesign(\"Completely Randomised Design\") %>%\n  set_units(unit = 30) %>%\n  set_trts(trt = 5) %>%\n  allot_trts(trt ~ unit) %>%\n  assign_trts(\"random\", seed = 1) %>%\n  serve_table() \n\n# Completely Randomised Design \n# An edibble: 30 x 2\n         unit      trt\n * <unit(30)> <trt(5)>\n 1     unit1      trt1\n 2     unit2      trt4\n 3     unit3      trt3\n 4     unit4      trt5\n 5     unit5      trt2\n 6     unit6      trt5\n 7     unit7      trt3\n 8     unit8      trt4\n 9     unit9      trt2\n10     unit10     trt1\n# … with 20 more rows\n\n\nA design table generated by takeout() is an object with a special class of edbl_table. When you print a takeout object, a table will be displayed like a typical edbl_table object but the recipe code will also be displayed prior to the table.\nYou can quickly plot the design using the autoplot() in the deggust package.\n\nautoplot(crd)"
  },
  {
    "objectID": "cookbook.html#randomised-complete-block-design",
    "href": "cookbook.html#randomised-complete-block-design",
    "title": "5  Cookbook",
    "section": "5.2 Randomised complete block design",
    "text": "5.2 Randomised complete block design\nA randomised complete block design, commonly abbreviated as RCBD, is contain two unit factors, a blocking factor and experimental unit factor, and a treatment factor. The experimental unit factor would be nested within the blocking factor with the number of units within each level of the blocking factor, \\(k\\), equal to the number of treatments, \\(t\\). Every treatment appears exactly once in each level of the blocking factor, so the number of blocks, \\(b\\), is the same as the number of replications, \\(r\\), i.e. \\(b = r\\).\n\nrcbd <- takeout(menu_rcbd(t = 6, r = 10))\nexamine_recipe(rcbd)\n\ndesign(\"Randomised Complete Block Design\") %>%\n  set_units(block = 10,\n            unit = nested_in(block, 6)) %>%\n  set_trts(trt = 6) %>%\n  allot_trts(trt ~ unit) %>%\n  assign_trts(\"random\", seed = 874) %>%\n  serve_table()\n\n\n\nautoplot(rcbd)\n\n\n\n\nSuppose now I tell you that there are only 3 units in block 1 and 4 units in block 2, and 5 units in block 3, while other blocks can have 6 units. How would you modify your design then? Still generate an RCBD but randomly remove the treatment allocation to match the block size? In comparison to the previous design, this design has 6 less units so it’s possible to have 9 replicates for each treatment. Generally you’d want to get close to a balanced design as possible so you have roughly an equal amount of information on all your treatments. If you randomly remove the treatment allocation to match the required block size, there’s no guarantee that you’ll end up with a balanced design. You’ll also find that there’ll be no named experimental design that matches the description of your units so you won’t be able to just select a design from the menu. This is where the edibble system aids you. In the fundamental edibble system, you put the experimental structure first before thinking about the treatment assignment.\n\nmbd <- design(\"Modified Block Design\") %>%\n  set_units(block = 10,\n            unit = nested_in(block, \n                               1 ~ 3,\n                               2 ~ 4,\n                               3 ~ 5,\n                               . ~ 6)) %>%\n  set_trts(trt = 6) %>%\n  allot_trts(trt ~ unit) %>%\n  assign_trts(\"random\", seed = 326) %>%\n  serve_table()\n\n\nautoplot(mbd)\n\n\n\n\nYou can see below that the number of replications are equal across the treatments. You can try changing the seed number above to generate another set of design and see if it still holds true (it should!).\n\ntable(mbd$trt)\n\n\ntrt1 trt2 trt3 trt4 trt5 trt6 \n   9    9    9    9    9    9"
  },
  {
    "objectID": "cookbook.html#latin-square-design",
    "href": "cookbook.html#latin-square-design",
    "title": "5  Cookbook",
    "section": "5.3 Latin square design",
    "text": "5.3 Latin square design\n\nlsd <- takeout(menu_lsd(t = 6))\nexamine_recipe(lsd)\n\ndesign(\"Latin Square Design\") %>%\n  set_units(row = 6,\n            col = 6,\n            unit = crossed_by(row, col)) %>%\n  set_trts(trt = 6) %>%\n  allot_trts(trt ~ unit) %>%\n  assign_trts(\"random\", seed = 907) %>%\n  serve_table()\n\n\n\nautoplot(lsd)"
  },
  {
    "objectID": "cookbook.html#factorial-design",
    "href": "cookbook.html#factorial-design",
    "title": "5  Cookbook",
    "section": "5.4 Factorial design",
    "text": "5.4 Factorial design\n\nfac <- takeout(menu_factorial(trt = c(3, 2)))\nexamine_recipe(fac)\n\ndesign(\"Factorial Design\") %>%\n  set_units(unit = 54) %>%\n  set_trts(trt1 = 3,\n           trt2 = 2) %>%\n  allot_trts(~unit) %>%\n  assign_trts(\"random\", seed = 339) %>%\n  serve_table()\n\n\n\nautoplot(fac)"
  },
  {
    "objectID": "cookbook.html#balanced-incomplete-block-design",
    "href": "cookbook.html#balanced-incomplete-block-design",
    "title": "5  Cookbook",
    "section": "5.5 Balanced incomplete block design",
    "text": "5.5 Balanced incomplete block design\n\nbibd <- takeout(menu_bibd(t = 5, r = 10, k = 4))\nexamine_recipe(bibd)\n\ndesign(\"Balanced Incomplete Block Design\") %>%\n  set_units(block = 12,\n            unit = nested_in(block, 4)) %>%\n  set_trts(trt = 5) %>%\n  allot_trts(trt ~ unit) %>%\n  assign_trts(\"random\", seed = 32) %>%\n  serve_table()\n\n\n\nautoplot(bibd)"
  },
  {
    "objectID": "cookbook.html#split-plot-design",
    "href": "cookbook.html#split-plot-design",
    "title": "5  Cookbook",
    "section": "5.6 Split-plot design",
    "text": "5.6 Split-plot design\n\nspd <- takeout(menu_split(t1 = 2, t2 = 4, r = 10))\nexamine_recipe(spd)\n\ndesign(\"Split-Plot Design | Split-Unit Design\") %>%\n  set_units(mainplot = 20,\n             subplot = nested_in(mainplot, 4)) %>%\n  set_trts(trt1 = 2,\n           trt2 = 4) %>%\n  allot_trts(trt1 ~ mainplot,\n             trt2 ~ subplot) %>%\n  assign_trts(\"random\", seed = 666) %>%\n  serve_table()\n\n\n\nautoplot(spd)"
  },
  {
    "objectID": "cookbook.html#strip-plot-design",
    "href": "cookbook.html#strip-plot-design",
    "title": "5  Cookbook",
    "section": "5.7 Strip-plot design",
    "text": "5.7 Strip-plot design\n\nstrip <- takeout(menu_strip(t1 = 3, t2 = 4, r = 9))\nexamine_recipe(strip)\n\ndesign(\"Strip-Plot Design | Strip-Unit Design\") %>%\n  set_units(block = 9,\n            row = nested_in(block, 3),\n            col = nested_in(block, 4),\n            unit = nested_in(block, crossed_by(row, col))) %>%\n  set_trts(trt1 = 3,\n           trt2 = 4) %>%\n  allot_trts(trt1 ~ row,\n             trt2 ~ col) %>%\n  assign_trts(\"random\", seed = 987) %>%\n  serve_table()\n\n\n\nautoplot(strip) + facet_wrap(~block, scales = \"free\")"
  },
  {
    "objectID": "cookbook.html#graeco-latin-square-design",
    "href": "cookbook.html#graeco-latin-square-design",
    "title": "5  Cookbook",
    "section": "5.8 Graeco-Latin square design",
    "text": "5.8 Graeco-Latin square design\n\ngraeco <- takeout(menu_graeco(t = 9))\nexamine_recipe(graeco)\n\ndesign(\"Graeco-Latin Square Design\") %>%\n  set_units(row = 9,\n            col = 9,\n            unit = crossed_by(row, col)) %>%\n  set_trts(trt1 = 9,\n           trt2 = 9) %>%\n  allot_trts(trt1 ~ unit,\n             trt2 ~ unit) %>%\n  assign_trts(\"random\", seed = 149) %>%\n  serve_table()\n\n\n\nautoplot(graeco)"
  },
  {
    "objectID": "cookbook.html#hyper-graeco-latin-square-design",
    "href": "cookbook.html#hyper-graeco-latin-square-design",
    "title": "5  Cookbook",
    "section": "5.9 Hyper-Graeco-Latin square design",
    "text": "5.9 Hyper-Graeco-Latin square design\n\nhyper_graeco <- takeout(menu_hyper_graeco(t = 6))\nexamine_recipe(hyper_graeco)\n\ndesign(\"Hyper-Graeco-Latin Square Design\") %>%\n  set_units(block1 = 6,\n            block2 = 6,\n            block3 = 6,\n            block4 = 6,\n            unit = crossed_by(block1, block2, block3, block4)) %>%\n  set_trts(trt = 6) %>%\n  allot_trts(trt ~ unit) %>%\n  assign_trts(\"random\", seed = 49) %>%\n  serve_table()\n\n\n\nautoplot(hyper_graeco)\n\nWarning: Too manu units so 296 units dropped from the plot. If you want to see\nall, use `nnode_max = Inf` or use `page = 2` to see the next set."
  },
  {
    "objectID": "cookbook.html#youden-square-design",
    "href": "cookbook.html#youden-square-design",
    "title": "5  Cookbook",
    "section": "5.10 Youden square design",
    "text": "5.10 Youden square design\n\nyouden <- takeout(menu_youden(nc = 4, t = 5))\nexamine_recipe(youden)\n\ndesign(\"Youden Square Design\") %>%\n  set_units(row = 5,\n            col = 4,\n            unit = crossed_by(row, col)) %>%\n  set_trts(trt = 5) %>%\n  allot_trts(trt ~ unit) %>%\n  assign_trts(\"random\", seed = 901) %>%\n  serve_table()\n\n\n\nautoplot(youden)"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Bailey, Rosemary. 2008. Design of Comparative Experiments.\n\n\nFisher, Ronald. 1935. The Design of Experiments. Oliver; Boyd.\n\n\nNational Commission for the Proptection of Human Subjects of Biomedical\nand Behavioral Research. 1978. “The Belmont Report: Ethical\nPrinciples and Guidelines for the Protection of Human Subjects of\nResearch.” Distributed by ERIC Clearinghouse.\n\n\nWickham, H. 2010. “A Layered Grammar of Graphics.”\nJournal of Computational and Graphical Statistics: A Joint\nPublication of American Statistical Association, Institute of\nMathematical Statistics, Interface Foundation of North America.\n\n\nWickham, Hadley. 2016. Ggplot2: Elegant Graphics for Data\nAnalysis. Springer-Verlag New York. https://ggplot2.tidyverse.org.\n\n\nWilkinson, Leland. 2005. The Grammar of Graphics. Springer."
  }
]