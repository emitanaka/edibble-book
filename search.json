[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Grammar of Experimental Designs",
    "section": "",
    "text": "Note\n\n\n\nHi there! This book is a work-in-progress.\n\n\nThe book will include about the basics of experimental design and how to get started with the edibble R-package and its extensions to plan, design and simulate experiments.\nAn experimental design is a huge field, and no doubt I know only a small portion of it. So if you find mistakes or I’m not giving enough due attention or credit to an important concept, please feel to let me know."
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Preface",
    "section": "",
    "text": "This book is intended for anyone who is interested in planning, designing and simulating experiments with a programming language. The programming is illustrated with the R language, however, the concept may be generalised to other programming languages.\nThe book can also serve as a reference to both undergraduate and graduate courses. Each section has problems that can be used as exercise for students. The book can also be used by practitioners that are involved with scientific or industrial experiments. The book will include plenty of examples spanning a diverse range of disciplines.\nIt is beneficial to have at least some knowledge of R. Readers may like to read XXX for basic knowledge in R and “R for Data Science” for tidyverse approaches to data analysis in R.\nThe book primarily makes use of ggplot2 for drawing static plots. The default color scheme and theme are modified as below and are applied for all plots produced by ggplot2 henceforth."
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "1  Basics",
    "section": "",
    "text": "Note\n\n\n\nHi there! This book is a work-in-progress.\nThere are many articles and books dedicated to explaining the concepts of experimental designs. This includes the seminal book by Fisher (1935), Bailey (2008), etc. This chapter presents an overview of the statistical concepts that are most pertinent in designing an experiment.\nMost experiments are comparative in nature, or more specifically, most experiments involve study of two or more experimental conditions in which the primary interest is to compare the outcome under the different conditions. You’ll therefore find that most experiments in this book are comparative experiments.\nAt the heart of each experiment, we are ultimately seeking confidence in any conclusion we are making from the analysis of the experimental data. What is perhaps not emphasised enough is that the experiments are human endeavours. Often there are multiple people involved in running experiments and a key challenge is to ensure each individual has sufficient understanding to play their role well. We touch more on this in Chapter 4.\nAll experiments have a cost whether that be financial, resources, time or other. We can consider the experimental cost as a function of the ability to redo the experiment again. For example, if your experimental resources are based on examination of fossils and the fossils are destroyed in the experimental process, then the cost of the experiment is infinite – you only have one chance to do the experiment – so it’s absolutely essential that you plan, design and execute the experiment well.\nDoing an experimental well requires a good understanding of the subject matter so that potential sources of variation can be controlled or accounted for in the experimental design. Prior to the collection of data, the statistical component of an experiment tends to be focussed on the design of the experiment, i.e. how the treatments are assigned to experimental units under practical constrains to maximise the statistical information of interest. Under this consideration, the statistical problem for experimental design is often reduced to either a randomisation or an optimisation problem and the experimental context may be stripped away in the generation of the design using computer software. We discuss this in ?sec-context, describe a system that encourages higher order thinking of the experimental design, termed the grammar of experimetnal designs, in Chapter 2, implemented as the edibble R-package and present how to get started with the edibble system to construct experimental design in Chapter 3.\nBefore we get into the crux of the basics of the experimental design, consider the three scenarios below. Each scenario describes an experiment where technical details have been reduced so it doesn’t serve as a distraction for now. For each scenario, try to see if you can identify what are the basic components to build the design of the experiment."
  },
  {
    "objectID": "basics.html#sec-terminology",
    "href": "basics.html#sec-terminology",
    "title": "1  Basics",
    "section": "1.1 Basic terminology",
    "text": "1.1 Basic terminology\nThe field of experimental design is large and is applied to many domains. While some specialised terminology exist, the following terminology are basic terms that are commonly understood across domains:\n\ntreatments: the whole set of experimental conditions in which the units are subjected to,\nexperimental unit: the smallest unit in which the treatment can independently be applied,\nobservational unit: the smallest unit in which the response is measured on,\nblock or cluster: the grouping of another unit such that the units within the same block or cluster is more alike in some aspect than units in different blocks or clusters,\ndesign: the allocation of treatment to units,\nplan or layout: the actual assignment of treatment to units, and\nexperimental structure: the arrangements or constrains of experimental factors – the structure can be broadly categorised as:\n\nunit structure: the relation between the units, e.g. pots nested in particular glasshouses, subjects segregated by sex, and so on; and\ntreatment structure: the division of treatment levels to meaningful groups, e.g. factorial structure means all combinations across the different treatment factors.\n\n\nThe above terminology describe the experimental factors and its associations. More specifically, experimental factors are any variables that pertain to the experiment (physical or otherwise) and includes the treatments, experimental units, observational units and blocks/clusters. The associations of experimental factors include its nesting structure or say the assignment of treatment to units.\nIn addition to above, there are commonly understood terminology that refer to the properties of experimental designs. These include:\n\nbalanced experiment: refers to when the replication of the treatments are equal,\northogonal design\ncomplete design: every treatment appears exactly once in each block or cluster.\n\n\n\n\n\n\n\n plant growth\n\n\n\n\nThe experimental aim is to study the effects of plant growth of four particular bacterial strains.\nThe experimental units are …\n\n\n\n\n1.1.1 Specialised terminology\nExperimental design is applicable across numerous domains, so perhaps it is not surprising that there are domain specific or specialised terminology that is used to describe the whole experimental designs, e.g. Latin Square Design, Step-Wedge Trial, Beehive Design and so on. Some recipe of these named experimental design are presented and discussed in Chapter Section 5."
  },
  {
    "objectID": "basics.html#principles",
    "href": "basics.html#principles",
    "title": "1  Basics",
    "section": "1.2 Principles",
    "text": "1.2 Principles\nAll experiments have a potential to go wrong – plans may not be followed to the letter; you can’t distinguish which factor had the effect; or unknown factor is affecting the response. The degree of how wrong it went can vary but in some cases you wouldn’t even know it went wrong!\nIn designing an experiment, there are some safety measures that you can put in place to minimise potential issues. The basic statistical principles of experimental design outlined below form some of these safety measures.\n\n1.2.1 Randomisation and optimisation\nRandomisation in the context of experimental design means that the treatment allocation to units were probabilistically determined by a mechanism where the outcome of the allocation is not (consciously or unconsciously) influenced by those involved in the experiment. The opposite spectrum of randomisation is systematic allocations of treatments to units – this means that the allocations are not probabilistic and if you know the systematic order, then you can precisely infer the allocation.\nRandomisation is a core principle of experimental design. When you conduct an experiment, you are investigating factors to understand some process or phenomenon, and there will be factors which affect the response that you don’t know about – if you did, you could try to control that variable in your experiment. Randomisation protects the experiment, with no guarantee however, from potential bias.\n\n\n\n\n\n\nHow to randomise\n\n\n\nTypically you can use some software to draw a random sample; in this instance it’d be a good idea to ensure this randomisation can be replicated. In R, this is typically achieved by using set.seed().\nIn some cases, you can use physical tools to do your randomisation so long as the tool doesn’t introduce some bias. E.g. flipping an unbiased coin or blindly drawing a paper with a number written from a covered box. While it’s easier to replicate the randomisation using a computational tool like R, it’s far more important to present the treatment allocation in a manner that the subjects involved in the experiment can accept it. For example, a water-sensitive revitalisation is planned for settlements in a developmental country such that half the settlements will be allocated to early intervention, the other half late intervention. The local community doesn’t have an understanding about randomisation but the concept of lottery is familiar – a grand ceremony is taken place with representative of the settlements drawing out a ball that allocates the settlement to early or late intervention.\n\n\nNot all experiments can allocate treatments to units randomly, e.g. you can’t get your participants to smoke to study the effect of smoking, nor can you get a random agricultural land to have a drought to study how well a crop grows under drought conditions. These types of experiments are referred to as quasi-experiments or natural experiments.\nOptimisation in the context of experimental design generally means that the treatment allocation to units were found by optimising some given criteria, usually denoted by a single letter (A, C, D, etc). These optimality-criteria are based on a statistical model,\n\\[\\begin{equation} \\boldsymbol{y} =  \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{e},\\end{equation}\\] where \\(\\boldsymbol{y}\\) is a vector of yet unobserved responses, \\(\\boldsymbol{\\beta}\\) is a vector of experimental factor effects (e.g. treatment, block, etc), \\(\\mathbf{X}\\) is the so-called design matrix (comprising of 0s and 1s) that map the experimental factor levels to a response, and \\(\\boldsymbol{e}\\) is a vector of errors.\n\n\n\n\n\n\n\n Design matrix for plant growth example\n\n\n\nConsider again Scenario 1 where an experiment studies three bacterial strains known for promoting plant growth under osmotic stress. The design matrix, \\(\\mathbf{X}\\) below shows the mapping fo the six plant units to the baterial strain.\n\\[\\mathbf{X} = \\begin{bmatrix}1 & 0 & 0  \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 1  & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & 1\\end{bmatrix}\\qquad \\boldsymbol{\\beta} = \\begin{bmatrix}\\class{fa-solid fa-virus}{}\\\\ \\class{fa-solid fa-bacterium}{}\\\\ \\class{fa-solid fa-disease}{}\\\\ \\end{bmatrix} \\qquad \\underset{\\text{illustrative}}{\\mathbf{X}\\boldsymbol{\\beta} =  \\begin{bmatrix}\\class{fa-solid fa-virus}{} \\rightarrow \\class{fa-solid fa-seedling}{}_1\\\\\\class{fa-solid fa-virus}{} \\rightarrow \\class{fa-solid fa-seedling}{}_2\\\\\\class{fa-solid fa-bacterium}{} \\rightarrow \\class{fa-solid fa-seedling}{}_3\\\\\\class{fa-solid fa-bacterium}{} \\rightarrow \\class{fa-solid fa-seedling}{}_4\\\\\\class{fa-solid fa-disease}{} \\rightarrow \\class{fa-solid fa-seedling}{}_5\\\\\\class{fa-solid fa-disease}{} \\rightarrow \\class{fa-solid fa-seedling}{}_6\\end{bmatrix}}\\]\n\n\nIf we assume \\(\\boldsymbol{e} \\sim N(\\boldsymbol{0}, \\sigma^2\\mathbf{I})\\) and \\(\\boldsymbol{\\beta}\\) are fixed effects, then \\(\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^\\top\\mathbf{X})^{-1}\\mathbf{X}^\\top\\boldsymbol{y}\\) and \\(var(\\hat{\\boldsymbol{\\beta}}) = \\sigma^2(\\mathbf{X}^\\top\\mathbf{X})^{-1}\\) where \\(\\mathbf{X}\\) is assumed to be full rank. Note in particular that \\(var(\\hat{\\boldsymbol{\\beta}}) \\propto (\\mathbf{X}^\\top\\mathbf{X})^{-1}\\) so if the model is reasonable then the variance of parameter estimates is determined by the design matrix.\n\n\n\n\n\n\nWhere \\(\\mathbf{X}\\) is not full rank\n\n\n\nIf \\(\\mathbf{X}\\) is not full rank, then there are many possible inverses of \\(\\mathbf{X}^\\top\\mathbf{X}\\), termed generalised inverse with notation as \\((\\mathbf{X}^\\top\\mathbf{X})^{-}\\).\n\n\nThe list of optimal-criteria are:\n\nA-optimality finds \\(\\mathbf{X}\\) such that it minimises \\(\\text{tr}\\left((\\mathbf{X}^\\top\\mathbf{X})^{-1}\\right)\\),\nC-optimality finds \\(\\mathbf{X}\\) such that it minimises \\(var(\\boldsymbol{c}^\\top\\hat{\\boldsymbol{\\beta}})\\),\nD-optimality finds \\(\\mathbf{X}\\) such that it maximises \\(det\\left((\\mathbf{X}^\\top\\mathbf{X})^{-1}\\right)\\),\nE-optimality finds \\(\\mathbf{X}\\) such that it maximises the minimume eigenvalue of \\((\\mathbf{X}^\\top\\mathbf{X})^{-1}\\),\n… and so many more\n\n\n\n\n\n\n\nOptimised designs are not necessary randomised\n\n\n\nThis means that even if the design has been constructed as to optimise some criteria, you are missing out on the benefits of the randomisation. Some experimental structure results in a multiple possible treatment allocations with the same optimal criteria and the software may be selecting this in a systematic way.\n\n\n\n\n\n\n\n\nOptimal designs for complex experiments\n\n\n\nOptimised designs for complex experiments can be computationally expensive. In these cases, the algorithm may be searching heuristically. You should try searching under different starting values and compare the optimal criteria obtained.\n\n\n\n\n1.2.2 Bias and confounding\nBiases can lurk into an experiment in many forms.\n\n\n\n\n\n\nExamples of biases\n\n\n\n\nTo test the effectiveness of flu vaccines, a trial for vaccine 1 is done in January and a trial for vaccine 2 is done in July.\nTo study the effects of different diets for pigs, diet A is given to the first set of pigs that the farmer caught and the remaining (faster) pigs received diet B.\nA doctor decides to assign the treatment to the sickest patients while the control treatment is assigned to the healthiest patients.\n\n\n\nBiases are not necessary introduced into study with malicious or known intent (e.g. trying to ensure certain treatments have a better outcome by manipulating the treatment assignment). The third example is a case where the intention of the doctor is well but is introducing a selection bias.\n\n\n1.2.3 Replications, repetition and duplication\nIn a comparative experiment, treatments are allocated to units but every unit has an individual variation (with exceptions for some, e.g. computer experiments). To distinguish the individual variation from the treatment variation, you need replication of the treatment allocation to another independent unit.\nAs a simple example, consider Figure 1.1 – 2 treatments are allocated to 3 participants each. If you ever only look at the outcome of a single replication in isolation, you wouldn’t know whether the outcome is a result of the treatment the participant received or some innate biological attribute of the participant, thus nothing to do with the treatment. Only by replicating and getting similar results with other sets of participants can you start to feel confident that the outcome may be associated with the treatment.\n\n\n\n\n\nFigure 1.1: A comparative experiment with two treatments allocated to six participants. Each treatment is replicated thrice with the same outcome for the same treatment.\n\n\n\n\nSuppose now that in Figure 1.1, participants in Replicate 3 are biological sisters of participants in Replicate 1. In this case, Replicate 3 is not a complete replicate. As biological sisters, they would share genetics (and perhaps the environment) that makes it harder to feel confident that the outcome is due to treatment instead of other shared factors between the participants.\n\n1.2.3.1 How many replications?\n\n\n1.2.3.2 Pseudo-replications"
  },
  {
    "objectID": "basics.html#summary",
    "href": "basics.html#summary",
    "title": "1  Basics",
    "section": "1.3 Summary",
    "text": "1.3 Summary\nThe major concepts this chapter covered are:\n\nbasic statistical terminology for experimental design\nimportance of replication and randomisation in experiments\npitfalls of pseudo-replication"
  },
  {
    "objectID": "basics.html#exercises",
    "href": "basics.html#exercises",
    "title": "1  Basics",
    "section": "1.4 Exercises",
    "text": "1.4 Exercises\n\nA farmer would like to know which diet is most effective in increasing the weight of the pigs. There are three types of diet that he wishes to test. For this scenario, describe the experimental aim, treatments, experimental units, observational units and the experimental design.\n\n\n\n\n\nBailey, Rosemary. 2008. Design of Comparative Experiments.\n\n\nFisher, Ronald. 1935. The Design of Experiments. Oliver; Boyd."
  },
  {
    "objectID": "grammar.html",
    "href": "grammar.html",
    "title": "2  Grammar",
    "section": "",
    "text": "Note\n\n\n\nHi there! This book is a work-in-progress.\nChapter 1 described a number of basic terms and concepts in experimental designs. In this chapter, I dissect these basic terms in order to build the “grammar of experimental designs”. The so-called grammar of experimental designs is a term that is heavily influenced by Wilkinson (2005), who use the term “grammar of graphics” to describe an object-oriented system to create unlimited number of plots from following a relatively small number of rules. The grammar of graphics is adopted across many systems (Julia, Python, R, Tableau and so on) with its most popular interpretation (H. Wickham 2010) as the ggplot2 R-package (Hadley Wickham 2016). An overview of ggplot2 is given in Section 2.4. The grammar of experimental designs leverage aspects of the grammar of graphics for the visualisation of the experimental designs as discussed more extensively in Section 2.5.\nHenceforth, “grammar” refers to the grammar of experimental designs unless explicitly stated otherwise."
  },
  {
    "objectID": "grammar.html#fundamental-terminology",
    "href": "grammar.html#fundamental-terminology",
    "title": "2  Grammar",
    "section": "2.1 Fundamental terminology",
    "text": "2.1 Fundamental terminology\nSection 1.1 describe the basic terminology used in the field of experimental design. We can, however, describe some terms more fundamentally by considering every categorised entity (physical or otherwise) involved in the experiment to be a factor in the design. The two primary roles of a factor are treatments and units; under this categorisation blocks, experimental units and observational units are all just units – the specific role of the unit is determined by the relationship of the factors. For example, if a treatment factor is allocated to a plot factor, then the plot is an experimental unit.\n\n\n\n\n\n\nIn the grammar, the different types of units (block, cluster group, subject, plot, etc) are all classified as units. There are no explicit specification of what is an experimental, observational or blocking units as these can be determined implicitly by the relationship of the factors.\n\n\n\nIn the grammar, an intermediate construct of the experimental design is stored as an object that contain two types of directed graphs, \\(G_F = (V(G_F), E(G_F))\\) and \\(G_L = (V(G_L), E(G_L))\\), where \\(V(G_F)\\) and \\(V(G_L)\\) are sets of vertices and \\(E(G_F)\\) and \\(E(G_L)\\) are sets of edges. We refer \\(G_F\\) and \\(G_L\\) as factor graph and level graph, respectively. In the factor graph, every factor is represented as a single vertex. Every factor has a finite number of levels and each of these levels is represented as a single vertex in the level graph.\n\n\n\n\nA factor graph shows a high order view of the relationship between the factors in the experiment. In the above figure, there are two treatment factors: irrigation and fertilizer. Irrigation treatment is applied to the mainplot and the fertilizer treatment is applied to the subplot. The arrow from mainplot node to the subplot node implies that the subplot is nested in the mainplot. The shape and color of the node correspond to the class of the factor (e.g. unit, treatment).\n\n\n\n\n\n\nThe above figure shows the level graph. The nodes of the same color are the levels of the same factor (e.g. all yellow nodes correspond to the levels of the unit, subplot). The shape of the node correspond to the class of the corresponding factor.\n\n\n\n\n\n\n\n\nAll nodes in the factor graph must be explicitly named.\n\n\n\nTable (tab:exam-table?) shows an example of an illustrative experiment that tests the exam score on a different exam time allocation for two different subjects. In such an experiment, the observational unit may be specified as the combination of Subject-Student, i.e. an observational unit can only be uniquely identified by using information across multiple factors. In the grammar, a factor cannot be implicitly assumed from other factors. This restriction means, for example, that a new factor, like Exam Booklet, which uniquely identifies every Subject-Student combination must be specified in the system. This restriction is not only for the purpose of internal graph representation but forces the user to confront what the observational units actually are. Naming things are hard, but without naming things, it can be hard to create a shared understanding about the experimental structure.\n\n\n\nThe table below shows the exam time allocation for every subject-student combination.\n \n  \n    Exam Booklet \n    Subject \n    Student \n    Exam Time \n    Score \n  \n \n\n  \n    1 \n    Math \n    1 \n    Morning \n    58 \n  \n  \n    2 \n    Science \n    1 \n    Afternoon \n    90 \n  \n  \n    3 \n    Math \n    2 \n    Afternoon \n    39 \n  \n  \n    4 \n    Science \n    2 \n    Morning \n    80 \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\nobject\nclass\npurpose\n\n\n\n\nedibble factor\nedbl_fct\na factor pertaining to the experimental design\n\n\nedibble unit\nedbl_unit\nany entity, except treatment factors, that pertains to the experiment\n\n\nedibble treatment\nedbl_trt\ntreatment factor in the experiment such that the factorial combination describes the whole treatment levels\n\n\nedibble response\nedbl_rcrd\nthe intended response to be measured during the experiment\n\n\nedibble graph\nedbl_graph\nan intermediate construct of the experimental design\n\n\nedibble table/data frame\nedbl_table\na tibble output for experimental design\n\n\n\nAn edibble variable is any variable that is relevant in any aspect of the experiment (not just the design of experiment). An edibble variable can be physical (e.g. person, plot, animal and drug), metaphysical (e.g. gender, time and space) or intended response measures.\nThere are three main types of edibble variable: an edibble unit (edbl_unit), an edibble treatment factor (edbl_trt), and an edibble record (edbl_rcrd).\nCurrently, variables are limited to categorical variables.\nEvery edibble variable comes in two forms:\n\na vertex form which contains:\n\nname: variable name,\nclass: \"edbl_unit\", \"edbl_trt\", or \"edbl_rcrd\",\nvtype: \"var\",\ngraphical attributes like label, and\nconnected to child level nodes which contain:\n\nname: level name,\nlabel: the level name,\nvtype: \"level\", and\ngraphical attributes like label.\n\n\na vector form which is an integer vector which has classes edbl_var, factor and vctrs_vctr with attributes:\n\nname: variable name,\nclass: a character vector containing \"edbl_var\", \"factor\", and \"vctrs_vctr\", and\nlevels: a character vector of the level names.\n\n\nThe vector format behaves much like a factor except that the output is modified to include the number of levels in tibble output."
  },
  {
    "objectID": "grammar.html#an-edibble-graph",
    "href": "grammar.html#an-edibble-graph",
    "title": "2  Grammar",
    "section": "2.2 An edibble graph",
    "text": "2.2 An edibble graph\nAn edibble graph, or edbl_graph object, is a special type of directed graph. This form is used to represent intermediate constructs of the experimental design.\nIn a factor graph:\n\na vertex is a variable,\nan edge is a high-level connection between two variables, and\nthe direction of an edge defines a relationship based on which two variables it is connecting. Say if we have two nodes named A and B with a directed edge starting from A to B, then the meaning of the relationship follows the table below. If the combination is not listed below then the nodes cannot have a direct relationship.\n\n\n\n\nA\nB\n\\(A \\rightarrow B\\) relationship\n\n\n\n\nunit\nunit\nB is nested in A\n\n\ntreatment\nunit\nB is applied to A\n\n\nrecord\nunit\nB is measured on A\n\n\n\nAs an example, consider a split-plot design that contains 4 main plots with 2 sub plots within each main plot (so 8 subplots in total). There are 2 treatment factors: fertilizer (with levels A and B) and variety (with levels V1 and V2). Each level of the fertilizer is randomly applied to two main plots. Each level of variety is randomly applied to one sub plot within each main plot. Two responses are planned to be measured on the sub plots: yield and height.\nIn a level graph:\n\na vertex is a level,\nan edge is a direct connection between two levels, and\nthe direction of an edge defines the same relationship as for high-level view, except if the edge is connecting nodes of levels of the same unit variable then it represents the sequence order of the levels.\n\nThe whole edibble graph object contains all the nodes and edges from the high- and low-level views. The whole edibble graph can have numerous nodes and edges, even when the number of units are small, that it’s visualisation will be too cluttered to be any useful. Consequently, when visualising these intermediate construct of the experimental design, only a high- or low-level view is visible to the user, but the object contains the information seen in both views."
  },
  {
    "objectID": "grammar.html#an-edibble-table-or-data-frame",
    "href": "grammar.html#an-edibble-table-or-data-frame",
    "title": "2  Grammar",
    "section": "2.3 An edibble table (or data frame)",
    "text": "2.3 An edibble table (or data frame)\nAn edibble, or edbl_table object, is a special class of tibble. The word “edibble” itself already implies that it is a table so appending the word with table or data frame seems superfluous. However, edibble can refer to the package, object, or used as an adjective to other objects, so appending edibble with table or data frame is to make explicit emphasis it refers to the edbl_table object, otherwise the reader is expected to infer its meaning by context.\nAn edbl_table was originally called edbl_df following convention from tibble but I decided to break away from this since other edibble components are graph and design, so a two letter word felt too short in contrast.\nAn edibble data frame is produced when the variables can be laid out in a tidy data format. An edibble is constructed from two possible ways:\n\nconverting edibble graph to edibble using serve_table and\nconverting existing data frame to edibble using edibble."
  },
  {
    "objectID": "grammar.html#sec-ggplot",
    "href": "grammar.html#sec-ggplot",
    "title": "2  Grammar",
    "section": "2.4 The (layered) grammar of graphics",
    "text": "2.4 The (layered) grammar of graphics"
  },
  {
    "objectID": "grammar.html#sec-deggust",
    "href": "grammar.html#sec-deggust",
    "title": "2  Grammar",
    "section": "2.5 Graphics for design of experiments",
    "text": "2.5 Graphics for design of experiments\n\n\n\n\nWickham, H. 2010. “A Layered Grammar of Graphics.” Journal of Computational and Graphical Statistics: A Joint Publication of American Statistical Association, Institute of Mathematical Statistics, Interface Foundation of North America.\n\n\nWickham, Hadley. 2016. Ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. https://ggplot2.tidyverse.org.\n\n\nWilkinson, Leland. 2005. The Grammar of Graphics. Springer."
  },
  {
    "objectID": "edibble.html",
    "href": "edibble.html",
    "title": "3  Getting started",
    "section": "",
    "text": "Note\n\n\n\nHi there! This book is a work-in-progress.\nThe experimental planning in this book is supported by the edibble R-package and its extensions. The edibble system is built on the principle that the system must make it easy to recover experimental context by encouraging the user to be explicit about experimental details. To get started with using the system, you need to first load the package:"
  },
  {
    "objectID": "edibble.html#setting-the-experimental-structure-and-context",
    "href": "edibble.html#setting-the-experimental-structure-and-context",
    "title": "3  Getting started",
    "section": "3.1 Setting the experimental structure and context",
    "text": "3.1 Setting the experimental structure and context\nIn the edibble system, an experiment design is built step-by-step. In the first step, you start with initialising the design by using the design() where the user can supply an optional title of the experiment. All subsequent steps are best specified after using the pipe operator (%>%) re-exported from the magrittr package or the native pipe operator (|>) available from R version 4.1 onwards. For example, below we carry out the following steps:\n\ninitiate an experiment called “My first experiment” via design();\nset 24 pots with set_units(); and then\nset treatments with 3 levels: 2 bacterial strains (PM398 and ZNP1) and no innoculation with set_trts().\n\n\nmydesign1 <- design(\"My first experiment\") %>% \n  set_units(pot = 24) %>% \n  set_trts(innoculation = c(\"PM398\", \"ZNP1\", \"none\"))\n\nThese steps create and modify a so-called “edibble design” (edbl_design) object that is used to represent an intermediate construct of an experimental design. The arguments in the functions set_units() and set_trts() employ the convention that the left hand side (LHS) is the name of the factor and the input on the right hand side (RHS) defines the levels. If the RHS is a single integer then it’s assumed to be the number of levels and if it’s a vector then it’s the name of the levels.\nThe print out of this object, as seen below, is displayed like a tree summarising the variables defined thus far.\n\nmydesign1\n\nMy first experiment\n├─pot (24 levels)\n└─innoculation (3 levels)\n\n\nIf you view the print out in the terminal or console, you will actually see that text are color coded so it’s easier to distinguish between the type of variables (e.g. unit or treatment). The above print out in a terminal will be viewed like below. These colors are customisable as discussed in Section @ref(aes-custom).\n\n\n\n\n\nThe argument names in set_units and set_trts are not fixed, so you could easily change the name of the units or treatment to something more meaningful. Below we have another experiment which has a statistically equivalent experimental structure as the previous experiment (24 units and 3 levels of treatment), but it “reads” as a different experimental context – a typical user will realise that the experimental units are pigs and treatments are diet.\n\nmydesign2 <- design(\"My second experiment\") %>% \n  set_units(pig = 24) %>% \n  set_trts(diet = c(\"high-fat\", \"low-fat\", \"standard\"))\n\nmydesign2\n\nMy second experiment\n├─pig (24 levels)\n└─diet (3 levels)\n\n\nYou can define more than one unit factor or treatment factor. For example below, it reads as that there are: 3 pens (named “North”, “Shade” and “Meadow”), 18 pigs, 3 type of diets and 2 types of supplement given at a frequency of either daily or weekly.\n\ndesign(\"My experiment with multiple factors\") %>% \n  set_units(pen = c(\"North\", \"Shade\", \"Meadow\"),\n            pig = 18) %>% \n  set_trts(diet = c(\"high-fat\", \"low-fat\", \"standard\"),\n           supplement = 2, \n           # frequency of supplements:\n           frequency = c(\"daily\", \"weekly\"))\n\nMy experiment with multiple factors\n├─pen (3 levels)\n├─pig (18 levels)\n├─diet (3 levels)\n├─supplement (2 levels)\n└─frequency (2 levels)\n\n\nThe unit and treatment factors do not need to be defined in one call. The ordering of the functions is commutative where the factor is not dependent directly on another factor.\n\ndesign(\"My experiment with multiple factors\") %>% \n  set_units(pen = c(\"North\", \"Shade\", \"Meadow\")) %>%\n  set_trts(diet = c(\"high-fat\", \"low-fat\", \"standard\"),\n           supplement = 2) %>% \n  # frequency of supplements\n  set_trts(frequency = c(\"daily\", \"weekly\")) %>% \n  set_units(pig = 18) \n\nMy experiment with multiple factors\n├─pen (3 levels)\n├─diet (3 levels)\n├─supplement (2 levels)\n├─frequency (2 levels)\n└─pig (18 levels)\n\n\n\n3.1.1 A viable experimental design\n\n\n\n\n\n\nA viable experimental design is only specified if the relationship between the variables can be reconciled to a single observational unit.\n\n\n\nFor example below\n\ndesign(\"An invalid unit structure\") %>% \n  set_units(pen = 6,\n            pig = 18) %>% \n  serve_table()\n\n# An invalid unit structure \n# An edibble: 0 x 2\n# … with 2 variables: pen <unit(6)>, pig <unit(18)>\n\n\n\n\n3.1.2 Understanding the experimental context\n\n\n3.1.3 Fitting a variety of mental mode"
  },
  {
    "objectID": "edibble.html#map-trts",
    "href": "edibble.html#map-trts",
    "title": "3  Getting started",
    "section": "3.2 Mapping treatment to units",
    "text": "3.2 Mapping treatment to units\nThe above code creates an object that represents an intermediate construct of an experimental design. To complete the specification of a minimum experimental design, we still need to specify:\n\nthe mapping of the treatments to units, which is achieved using allot_trts(), and\nhow the treatments are actually allocated to units via assign_trts().\n\nThese step may feel redundant in experiments where there is exactly one unit factor and one treatment factor but it’s required for further generalisation to other experimental structures. In addition, it serves to re-enforce the specific actions to the user.\n\ndes <- design(\"My first animal experiment\") %>% \n  set_units(pig = 24) %>% \n  set_trts(diet = c(\"high-fat\", \"low-fat\", \"standard\")) %>% \n  allot_trts(diet ~ pig) %>% \n  assign_trts(order = \"random\", seed = 1) \n\nOnce a minimum viable experimental design has been specified, then you can generate the experimental design table (or tibble) called edibble by parsing the object to serve_table().\n\nserve_table(des)\n\n# My first animal experiment \n# An edibble: 24 x 2\n          pig     diet\n   <unit(24)> <trt(3)>\n 1      pig1  high-fat\n 2      pig2  low-fat \n 3      pig3  standard\n 4      pig4  high-fat\n 5      pig5  low-fat \n 6      pig6  standard\n 7      pig7  standard\n 8      pig8  high-fat\n 9      pig9  low-fat \n10      pig10 low-fat \n# … with 14 more rows\n\n\n\n3.2.1 Treatment allotment\n\ndiet_design <- function(...) {\n  design(\"A valid nested design\") %>% \n    set_units(pen = 6,\n              pig = nested_in(pen, 3)) %>% \n    set_trts(diet = c(\"high-fat\", \"low-fat\", \"standard\")) %>% \n    allot_trts(...) %>% \n    assign_trts(order = \"systematic\") %>% \n    serve_table()\n}\n\ndiet_design(diet ~ pig)\n\n# A valid nested design \n# An edibble: 18 x 3\n         pen        pig     diet\n   <unit(6)> <unit(18)> <trt(3)>\n 1      pen1      pig1  high-fat\n 2      pen1      pig2  low-fat \n 3      pen1      pig3  standard\n 4      pen2      pig4  high-fat\n 5      pen2      pig5  low-fat \n 6      pen2      pig6  standard\n 7      pen3      pig7  high-fat\n 8      pen3      pig8  low-fat \n 9      pen3      pig9  standard\n10      pen4      pig10 high-fat\n11      pen4      pig11 low-fat \n12      pen4      pig12 standard\n13      pen5      pig13 high-fat\n14      pen5      pig14 low-fat \n15      pen5      pig15 standard\n16      pen6      pig16 high-fat\n17      pen6      pig17 low-fat \n18      pen6      pig18 standard\n\n\n\ndiet_design(diet ~ pen)\n\n# A valid nested design \n# An edibble: 18 x 3\n         pen        pig     diet\n   <unit(6)> <unit(18)> <trt(3)>\n 1      pen1      pig1  high-fat\n 2      pen1      pig2  high-fat\n 3      pen1      pig3  high-fat\n 4      pen2      pig4  low-fat \n 5      pen2      pig5  low-fat \n 6      pen2      pig6  low-fat \n 7      pen3      pig7  standard\n 8      pen3      pig8  standard\n 9      pen3      pig9  standard\n10      pen4      pig10 high-fat\n11      pen4      pig11 high-fat\n12      pen4      pig12 high-fat\n13      pen5      pig13 low-fat \n14      pen5      pig14 low-fat \n15      pen5      pig15 low-fat \n16      pen6      pig16 standard\n17      pen6      pig17 standard\n18      pen6      pig18 standard"
  },
  {
    "objectID": "edibble.html#setting-records-with-expectations",
    "href": "edibble.html#setting-records-with-expectations",
    "title": "3  Getting started",
    "section": "3.3 Setting records with expectations",
    "text": "3.3 Setting records with expectations\nThe term “records”, often abbreviated as rcrd in the edibble system, refers to any observational variables, including response variables. Setting records is a way to describe the intent of the observations that you will collect in the experiment. All records must be made on a unit. The primary way to set the record is using set_rcrds() where the LHS is the factor name of the record and the RHS is the unit factor on which the record will be measured. The LHS of the input in set_rcrds() follow the same pattern as set_units() and set_trts() as the LHS is the name of the new factor. In the example below, we are measuring weight and sex of the pig and recording the manager of each pen. In this example there are only 6 pens, therefore there should be only a maximum of 6 managers recorded.\n\ndesr <- diet_design(diet ~ pen) %>% \n  set_rcrds(weight = pig,\n            sex = pig,\n            manager = pen) \n\ndesr\n\n# A valid nested design \n# An edibble: 18 x 6\n         pen        pig     diet weight    sex manager\n   <unit(6)> <unit(18)> <trt(3)> <rcrd> <rcrd>  <rcrd>\n 1      pen1      pig1  high-fat      ■      ■       ■\n 2      pen1      pig2  high-fat      ■      ■       x\n 3      pen1      pig3  high-fat      ■      ■       x\n 4      pen2      pig4  low-fat       ■      ■       ■\n 5      pen2      pig5  low-fat       ■      ■       x\n 6      pen2      pig6  low-fat       ■      ■       x\n 7      pen3      pig7  standard      ■      ■       ■\n 8      pen3      pig8  standard      ■      ■       x\n 9      pen3      pig9  standard      ■      ■       x\n10      pen4      pig10 high-fat      ■      ■       ■\n11      pen4      pig11 high-fat      ■      ■       x\n12      pen4      pig12 high-fat      ■      ■       x\n13      pen5      pig13 low-fat       ■      ■       ■\n14      pen5      pig14 low-fat       ■      ■       x\n15      pen5      pig15 low-fat       ■      ■       x\n16      pen6      pig16 standard      ■      ■       ■\n17      pen6      pig17 standard      ■      ■       x\n18      pen6      pig18 standard      ■      ■       x\n\n\nAnother equivalent way to set the record is using set_rcrds_of(). The format of the input is such that the unit factors are on the LHS and the RHS are character vectors of new record factor names. The reason that names are set as characters is because the factors in the RHS do not yet exist. In contrast, the RHS of the input in set_rcrds() is unquoted because those factors exist. The suffix _of in the function name is purposely chosen to signal that the pattern for the LHS no longer follows that of set_rcrds(), set_trts() and set_units() where the LHS is always a new factor name.\n\ndiet_design(diet ~ pen) %>% \n  set_rcrds_of(pig = c(\"weight\", \"sex\"),\n               pen = \"manager\")\n\nYou may choose to also set expecations of the record. For example, we assert below that the weight of a grown pig must be a minimum of 15 kg.\n\ndesre <- desr %>% \n  expect_rcrds(weight > 15,\n               factor(sex, levels = c(\"F\", \"M\")))\n\nYou might see that it is good principles to be explicit about the records but you may not feel motivated for such verbose coding. There are downstream benefits for this as explained in Sections @ref(simulate) and @ref(export)."
  },
  {
    "objectID": "edibble.html#simulate",
    "href": "edibble.html#simulate",
    "title": "3  Getting started",
    "section": "3.4 Simulating records",
    "text": "3.4 Simulating records\n\ndat <- desre %>% \n  simulate_rcrds(weight = sim_normal(~diet + pen + pig, sd = 25) %>% \n                   params(\"mean\", \n                          diet = c(\"high-fat\" = 300,\n                                    \"low-fat\" = 50,\n                                   \"standard\" = 150),\n                          pen = c(\"pen4\" = -270),\n                          pig = rnorm(18)),\n                 manager = sim_form(~pen) %>% \n                   params(pen = sample(rep(c(\"John\", \"Mary\", \"Jane\"), 2))),\n                 .seed = 1, .censor = NA)\n\ndat\n\n# A valid nested design \n# An edibble: 18 x 6\n         pen        pig     diet weight    sex manager\n   <unit(6)> <unit(18)> <trt(3)>  <dbl> <rcrd> <chr>  \n 1      pen1      pig1  high-fat  319.       ■ John   \n 2      pen1      pig2  high-fat  302.       ■ John   \n 3      pen1      pig3  high-fat  249.       ■ John   \n 4      pen2      pig4  low-fat    67.1      ■ Jane   \n 5      pen2      pig5  low-fat    48.9      ■ Jane   \n 6      pen2      pig6  low-fat    45.3      ■ Jane   \n 7      pen3      pig7  standard  114.       ■ Mary   \n 8      pen3      pig8  standard  139.       ■ Mary   \n 9      pen3      pig9  standard  161.       ■ Mary   \n10      pen4      pig10 high-fat   63.7      ■ Jane   \n11      pen4      pig11 high-fat   28.9      ■ Jane   \n12      pen4      pig12 high-fat   40.1      ■ Jane   \n13      pen5      pig13 low-fat    48.0      ■ Mary   \n14      pen5      pig14 low-fat    NA        ■ Mary   \n15      pen5      pig15 low-fat    40.8      ■ Mary   \n16      pen6      pig16 standard  140.       ■ John   \n17      pen6      pig17 standard  149.       ■ John   \n18      pen6      pig18 standard  178.       ■ John   \n\n\n\nggplot(dat, aes(pen, weight, color = diet)) + \n  geom_point(size = 3) \n\nWarning: Removed 1 rows containing missing values (geom_point)."
  },
  {
    "objectID": "edibble.html#export",
    "href": "edibble.html#export",
    "title": "3  Getting started",
    "section": "3.5 Exporting the design",
    "text": "3.5 Exporting the design"
  },
  {
    "objectID": "edibble.html#aes-custom",
    "href": "edibble.html#aes-custom",
    "title": "3  Getting started",
    "section": "3.6 Aesthetic customisations",
    "text": "3.6 Aesthetic customisations\nThe edibble system offers you many levels of aesthetic customisations. These customisation are mostly frivolous and serve as means for users to customise elements visually to their liking. The level of aethetic customisation in the edibble system is probably of little value in the grand aim of constructing an experimental design, but if a user finds the developer’s default choice is not to their liking, at least they have the ability to modify it."
  },
  {
    "objectID": "edibble.html#visualisation",
    "href": "edibble.html#visualisation",
    "title": "3  Getting started",
    "section": "3.7 Visualisation",
    "text": "3.7 Visualisation\n\nlibrary(deggust)"
  },
  {
    "objectID": "edibble.html#examples",
    "href": "edibble.html#examples",
    "title": "3  Getting started",
    "section": "3.8 Examples",
    "text": "3.8 Examples\n\n\n\n\n\n\nBailey (2008) Exercise 8.5\nIn a biotechnology experiment, plants were grown in 90 pots. Five different quantities of potassium were randomized to the pots, so that each quantity was applied to the soil in 18 pots. After each of 15, 30 and 45 days, one plant was randomly chosen from each pot and removed; nine small pieces were cut from it to be used for tissue culture. Three different levels of nutrition were each applied to three of the pieces of each plant removed at each time. After a certain further length of time, the number of plantlets growing in each piece of tissue was counted.\n\n\n\n\ndesign(\"Bailey (2008) Exercise 8.5\") %>% \n  set_units(pot = 90,\n            plant = nested_in(pot, 3),\n            piece = nested_in(plant, 9)) %>% \n  set_trts(pottasium = c(\"q1\", \"q2\", \"q3\", \"q4\", \"q5\"), \n           nutrition = 3) %>% \n  allot_trts(pottasium ~ pot,\n             nutrition ~ piece) %>% \n  assign_trts() %>% \n  set_rcrds(plantlets = piece) %>% \n  serve_table()\n\n# Bailey (2008) Exercise 8.5 \n# An edibble: 2,430 x 6\n          pot       plant      piece pottasium  nutrition plantlets\n   <unit(90)> <unit(270)> <unit(2k)>  <trt(5)>   <trt(3)>    <rcrd>\n 1       pot1      plant1    piece1         q2 nutrition1         ■\n 2       pot1      plant1    piece2         q2 nutrition3         ■\n 3       pot1      plant1    piece3         q2 nutrition3         ■\n 4       pot1      plant1    piece4         q2 nutrition1         ■\n 5       pot1      plant1    piece5         q2 nutrition2         ■\n 6       pot1      plant1    piece6         q2 nutrition2         ■\n 7       pot1      plant1    piece7         q2 nutrition2         ■\n 8       pot1      plant1    piece8         q2 nutrition3         ■\n 9       pot1      plant1    piece9         q2 nutrition1         ■\n10       pot1      plant2    piece10        q2 nutrition1         ■\n# … with 2,420 more rows\n\n\n\n\n\n\n\n\nBailey (2008) Exercise 9.6\nA horticultural research station intends to investigate the effects of two treatment factors on the total weight of apples produced from apple trees. One treatment factor is the method of thinning; that is, removing fruitlets at an early stage of development so that those remaining will be able to grow larger. There are five methods of thinning, coded as A,B,C,D,E. The second treatment factor is the type of grass to grow around the base of the tree to prevent the growth of weeds. There are five types of grass, coded as a,b,c,d,e. It is assumed that there is no interaction between method of thinning and type of grass. There are 25 trees available for the experiment. They are arranged in a 5×5 rectangle. Construct a suitable design.\n\n\n\n\ndf <- design(\"Bailey (2008) Exercise 9.6\") %>% \n  set_trts(thinning = c(\"A\", \"B\", \"C\", \"D\", \"E\"),\n           grass = c(\"a\", \"b\", \"c\", \"d\", \"e\")) %>% \n  set_units(row = 5,\n            col = 5,\n            tree = crossed_by(row, col)) %>% \n  set_rcrds(apple_weight_total = tree) %>% \n  allot_table(thinning ~ tree,\n              grass ~ tree)\n\nanatomy(df)\n\n\n\nSummary table of the decomposition for unit & trt (based on adjusted quantities)\n\n Source.unit df1 Source.trt     df2 aefficiency eefficiency order\n row           4 thinning#grass   4      0.5625      0.5000     2\n col           4 thinning#grass   4      0.5625      0.5000     2\n tree         16 thinning         4      1.0000      1.0000     1\n                 grass            4      1.0000      1.0000     1\n                 thinning#grass   8      0.2500      0.1000     2\n\nTable of information (partially) aliased with previous sources derived from the same formula\n\n Source df Alias                    In  aefficiency eefficiency order\n grass  1  thinning                 trt      0.6400      0.6400     1\n grass  4  ## Information remaining trt      0.6923      0.3600     2\n\nThe design is not orthogonal\n\nautoplot(df)\n\n\n\n\n\n\n\n\n\n\nBailey (2008) Exercise 9.6\nA road safety organization wishes to compare four makes of car tyre. The organization has four test cars and four test drivers. One working day is needed to fit new tyres to a car, take it for an exhaustive test-drive, take relevant measurements on tyre treads, record all details of the test-drive, and prepare the car for the next session. The organization has only one week in which to perform its tests. To keep each car properly balanced, the organization has decided that all four tyres on a car at any one time should be of the same make. Construct a suitable design for this trial.\n\n\n\n\ndf <- design(\"Tyre test\") %>%\n  set_units(car = 4,\n            driver = 4,\n            day = 5,\n            test_drive = crossed_by(day, car, driver),\n            #tyre = nested_in(test_drive, 4)\n            ) %>% \n  set_trts(make = 4) %>% \n  #set_rcrds(measure = tyre) %>% \n  allot_table(make ~ test_drive)\n\nanatomy(df)\n\n\n\nSummary table of the decomposition for unit & trt\n\n Source.unit df1 Source.trt df2 aefficiency eefficiency order\n car           3                                             \n driver        3                                             \n day           4                                             \n test_drive   69 make         3      1.0000      1.0000     1\n                 Residual    66                              \n\nautoplot(df)\n\n\n\n\n\n\n\n\n\n\nBailey (2008) Example 10.19\nA manufacturer of household appliances wants to find the best combination of wash temperature and drying temperature to produce unwrinkled cotton sheets at the end of the laundry session. He wants to compare four different wash temperatures and three different drying temperatures. He uses eight similar washing machines and six similar dryers. First, 48 cotton sheets are randomly allocated to the washing machines, six per machine. The wash temperatures are randomly allocated to the washing machines so that two machines are run at each temperature. After the wash, the six sheets in each machine are randomly allocated to the dryers, one per dryer. Then the drying temperatures are randomly allocated to the dryers so that two machines are run at each temperature. After the drying, all 48 sheets are scored by experts for how wrinkled they are.\n\n\n\n\ndf <- design(\"Bailey (2008) Example 10.19\") %>%\n  set_trts(wash_temp = 4,\n           dry_temp = 3) %>% \n  set_units(washer = 8,\n            dryer = 6,\n            sheet = 48) %>% \n  allot_units(washer ~ sheet,\n              dryer ~ washer/sheet) %>% \n  allot_trts(wash_temp ~ washer,\n              dry_temp ~ dryer) %>% \n  assign_trts(\"random\") %>% \n  assign_units(\"random\") %>% \n  set_rcrds(score = sheet) %>% \n  serve_table()\n\nanatomy(df)\n\n\n\nSummary table of the decomposition for unit & trt\n\n Source.unit df1 Source.trt         df2 aefficiency eefficiency order\n washer        7 wash_temp            3      1.0000      1.0000     1\n                 Residual             4                              \n dryer         5 dry_temp             2      1.0000      1.0000     1\n                 Residual             3                              \n sheet        35 wash_temp#dry_temp   6      1.0000      1.0000     1\n                 Residual            29                              \n\nautoplot(df)\n\n\n\n\n\n\n\n\n\n\nBailey (2008) Example 10.20\nAn agronomy institute in Brazil conducted a factorial experiment on beans. The treatment factors were cultivar (there were three cultivars), seeding (either conventional or with no tillage), and molybdenum (either applied or not). The experimental area was divided into four blocks. Each block was a 3×4 rectangle. The three rows were called strips; cultivars were applied to these. The four columns, which were called quarters, were grouped into two halves. The different seeding methods were used in the two halves of each block, and the Mo (molybdenum) was applied to one quarter in each half.\n\n\n\n\ndf <- design(\"Bailey (2008) Example 10.20\") %>% \n  set_trts(cultivar = 3,\n           seeding = c(\"conventional\", \"no tillage\"),\n           molybdenum = c(\"applied\", \"none\")) %>% \n  set_units(block = 4,\n            strip = nested_in(block, 3),\n            half = nested_in(block, 2),\n            quarter = nested_in(half, 2),\n            plot = nested_in(block, crossed_by(strip, quarter))) %>% \n  allot_table(cultivar ~ strip,\n              seeding ~ half,\n              molybdenum ~ quarter) \n\ndf\n\n# Bailey (2008) Example 10.20 \n# An edibble: 48 x 8\n    cultivar      seeding molybdenum     block      strip      half\n    <trt(3)>     <trt(2)>   <trt(2)> <unit(4)> <unit(12)> <unit(8)>\n 1 cultivar2 conventional    none       block1     strip1     half1\n 2 cultivar1 conventional    none       block1     strip2     half1\n 3 cultivar3 conventional    none       block1     strip3     half1\n 4 cultivar2 conventional    applied    block1     strip1     half1\n 5 cultivar1 conventional    applied    block1     strip2     half1\n 6 cultivar3 conventional    applied    block1     strip3     half1\n 7 cultivar2 no tillage      none       block1     strip1     half2\n 8 cultivar1 no tillage      none       block1     strip2     half2\n 9 cultivar3 no tillage      none       block1     strip3     half2\n10 cultivar2 no tillage      applied    block1     strip1     half2\n# … with 38 more rows, and 2 more variables: quarter <unit(16)>,\n#   plot <unit(48)>\n\nanatomy(df)\n\nWarning in pstructure.formula(formulae[[1]], keep.order = keep.order, grandMean\n= grandMean, : block:half is aliased with previous terms in the formula and has\nbeen removed\n\n\n\n\nSummary table of the decomposition for unit & trt (based on adjusted quantities)\n\n Source.unit         df1 Source.trt                  df2 aefficiency\n block                 3                                            \n half[block]           4 seeding                       1      1.0000\n                         Residual                      3            \n strip[block]          8 cultivar                      2      1.0000\n                         Residual                      6            \n quarter[block:half]   8 molybdenum                    1      1.0000\n                         seeding#molybdenum            1      1.0000\n                         Residual                      6            \n plot[block]          24 cultivar#seeding              2      1.0000\n                         cultivar#molybdenum           2      1.0000\n                         cultivar#seeding#molybdenum   2      1.0000\n                         Residual                     18            \n eefficiency order\n                  \n      1.0000     1\n                  \n      1.0000     1\n                  \n      1.0000     1\n      1.0000     1\n                  \n      1.0000     1\n      1.0000     1\n      1.0000     1\n                  \n\nTable of information (partially) aliased with previous sources derived from the same formula\n\n Source      df Alias       In   aefficiency eefficiency order\n half[block] 4  half[block] unit      1.0000      1.0000     1\n half[block] 0  ## Aliased  unit      1.0000      1.0000     1\n\n\n\n\n\n\n\n\nBailey (2008) Exercise 10.5\nIn an experiment into the digestibility of stubble, four feed treatments are to be applied to sheep. There are 16 sheep, in four rooms of four animals each. There are four test periods of four weeks each, separated by two-week recovery periods. Each sheep is to be fed all treatments, one in each test period. During the recovery periods all animals will receive their usual feed, so that they will return to normal conditions before being subjected to a new treatment.\n\n\n\n\ndes <- design(\"Bailey (2008) Exercise 10.5\") %>% \n  set_trts(feed = 4) %>% \n  set_units(room = 4,\n            sheep = nested_in(room, 4),\n            period = 4,\n            unit = crossed_by(period, sheep)) %>% \n  allot_table(feed ~ unit)\n\n# anatomy(des)\nautoplot(des)\n\n\n\n\n\n\n\n\n\n\nBailey (2008) Exercise 10.6\nAn experiment was carried out to find out if so-called ‘non-herbicidal’ pesticides affect photosynthesis in plants. Six pesticides were compared: diuron, carbofuran, chlorpyrifos, tributyltin chloride, phorate and fonofos. Each of these was dissolved in water at five different concentrations. In addition, plain water was used as a control treatment. Two petri dishes were used for each treatment. Each petri dish was filled with pesticide solution or water. Five freshly cut leaves from mung beans were floated on the surface ofthe solution in each dish. After two hours, the chlorophyll fluorescence of each leaf was measured.\n\n\n\n\ndesign(\"Bailey (2008) Exercise 10.6\") %>% \n  set_trts(pesticide = c(\"diuron\", \"carbofuran\", \"chlorpyrifos\", \"tributyltin chloride\", \n                         \"phorate\", \"fonofos\"),\n           concentration = 5) %>% \n  add_trts(pesticide = \"none\", concentration = NA) %>% \n  set_units(petri = 2 * ntrts())\n\n\n# emylyn's design\nlibrary(edibble)\ndes1 <- design(\"sensory evaluation\") %>% \n  set_units(day = 4,\n            consumer = nested_in(day, 42)) %>% \n  set_trts(cover_story = c(\"yes\", \"no\"),\n           test_half = c(\"triangle\", \"paired\"),\n           test_first = c(\"triangle/paired\", \"monadic\")) %>% \n  allot_table(test_half:cover_story ~ day,\n                         test_first ~ consumer, \n              order = c(\"systematic\", \"random\"))\n\nlibrary(tidyverse)\n\ndes1 %>% \n    filter(test_half == \"triangle\") %>% \n    select(day, consumer) %>% \n    # do the next design\n    restart_design(\"triangle test\") %>% \n    set_units(day, consumer) %>% \n    allot_units(consumer ~ nested_in(day)) %>% \n    # finished described relationship - new design variables\n    edbl_design() %>% \n    set_units(test = nested_in(consumer, 2), \n              product = nested_in(test, 3)) %>% \n    set_trts(spiked = c(\"1/3\", \"2/3\"),\n             pattern = c(\"XXO\", \"XOX\", \"OXX\")) %>% \n    allot_table(spiked ~ test, \n                pattern ~ product)\n\n\n\n\n\nBailey, Rosemary. 2008. Design of Comparative Experiments."
  },
  {
    "objectID": "management.html",
    "href": "management.html",
    "title": "4  Project management",
    "section": "",
    "text": "… communication is complex, fraught with tensions, misunderstandings, and problems — rather than a simple process of creating shared meaning.\n– Littlejohn et al., 2017, Theories of Human Communication\n\nAn experiment generally involves more than one person. For simplicity, let us suppose there are four actors:\n\nthe domain expert who drives the experimental objective and has the intricate knowledge about the subject area,\nthe statistician who creates the experimental design layout after taking into account statistical and practical constraints,\n\nthe technician who carries out the experiment and collects the data, and\nthe analyst who analyses the data after the data are collected.\n\nThe actors are purely illustrative and in practice, multiple people can take on each role, one person can take on multiple roles, and a person is not necessary a specialist in the role assigned (e.g. a statistician role can be carried out by a person who’s primarily training is not in statistics). All the roles can be acted out by a single individual. Ideally, all parties should have clarity of the final experimental design.\nTo carry out this experiment, the people involved in the experiment must come to some degree of shared understanding about the experimental motivations, limitations and protocol. This understanding is achieved by communication. People may opt for a series of behavioural cycles that facilitate the process of clarification as they work to reduce uncertainty about their understanding.\n\n\n\n\n\nEach actor does not need to have a full comprehension of the experiment, but rather focus on the most pertinent part of the experiment that is relevant to their role. For example in the guinea pig experiment [add ref], a statistician does not need to know how the guinea pigs were sourced for the experiment – just that the subjects are genetically identical – in fact, a statistician can generate an experimental design without even knowledge that the subjects are guinea pigs. From the view point of the statistician, the experiment can be simplified to its bare essential elements to generate the experimental design. Why then would there be any need to encode the context of the experiment in generating the experimental design?\nThe minimum required understanding for a statistician to conduct their role does not include understanding the experimental context. This is the reason perhaps that a lot of computational systems to generate the experimental design have often the inputs stripped off the experimental context. In an idealistic world, this approach would be fine but the major problem in this process is that the involved parties most likely do not know what is the most relevant knowledge for a statistician."
  },
  {
    "objectID": "cookbook.html",
    "href": "cookbook.html",
    "title": "5  Cookbook",
    "section": "",
    "text": "Note\n\n\n\nHi there! This book is a work-in-progress.\nEvery experiment requires a tailored design to properly suit the situation; you shouldn’t simply select an experimental design from a list of named designs. This concept isn’t unique to just experimental designs; take architecture for example where near identical “cookie-cutter” homes get built on masses to make development cheaper but it comes at a detrimental cost when it’s not fit for the landscape. There’s an economical cost that perhaps drive the use of cookie-cutter homes, but what’s the cost of using carefully tailored experimental designs? That you have to think more about the experiment? It’s a small cost if you think about the consequences of an ill-designed experiment. And I’m no real estate expert, but I wouldn’t invest in a cheap home that’s cutting corners to the point that it may have defects.\nNamed experimental design are handy in succinctly describing the experimental structure and treatment allotment to units, but you lose the direct association to the fundamental components that make up the experimental design. This can obscure seeing the association between different named experimental designs. The idea of the fundamental system in edibble is to encourage higher-order thinking from the user.\nThe use of named experimental designs is an endemic – it will continue to be prevalent in the field. So a compromising approach is used in the edibble system. For every named experimental design presented, there will be a function prefixed by menu_ that shows the recipe code in terms of the fundamental system. The user is supposed to copy-and-paste these code and modify the names of the units and treatments to their experimental context. You can choose to generate a design table using takeout(), but again I discourage you to use these approaches to generate a proper design.\nThe following sections present a number of recipes for some well known named experimental designs. The ingredients for each recipe are described in fundamental system terms (see Section @ref(grammar))."
  },
  {
    "objectID": "cookbook.html#completely-randomised-design",
    "href": "cookbook.html#completely-randomised-design",
    "title": "5  Cookbook",
    "section": "5.1 Completely randomised design",
    "text": "5.1 Completely randomised design\nA completely randomised design, commonly abbreviated as CRD, contain two factors: experimental units and treatments with a completely unstructured experiment (i.e. no grouping for the factors). CRD is sufficiently characterised by the number of units, \\(n\\), and the number of treatment, \\(t\\). Instead of \\(n\\), you ccan parameterise the design with the number of replications, \\(r\\); in which case, you can derive \\(n = rt\\). The later parameterisation means that the design will be balanced while the former does not guarantee that the design is balanced.\nYou can call on menu_crd() to see the code in the terms of the fundamental system. If you omit the argument values, then a random parameterisation will be selected for you. You can find more details about the design in the documentation (?menu_crd).\n\nmenu_crd()\n\ndesign(\"Completely Randomised Design\") %>%\n  set_units(unit = 23) %>%\n  set_trts(trt = 10) %>%\n  allot_trts(trt ~ unit) %>%\n  assign_trts(\"random\", seed = 679) %>%\n  serve_table()\n\n\nIf you want to generate the design table, then you can use the takeout() function parsing the named design object created by the set of menu_ functions. If you don’t select any menu then the takeout() function will automatically select a random menu for you. You can find the list of available named experimental designs by calling on scan_menu(). For now, let’s “takeout” the completely randomised design with 5 treatments and 30 experimental units.\n\ncrd <- takeout(menu_crd(t = 5, n = 30, seed = 1), )\ncrd\n\ndesign(\"Completely Randomised Design\") %>%\n  set_units(unit = 30) %>%\n  set_trts(trt = 5) %>%\n  allot_trts(trt ~ unit) %>%\n  assign_trts(\"random\", seed = 1) %>%\n  serve_table() \n\n# Completely Randomised Design \n# An edibble: 30 x 2\n         unit      trt\n * <unit(30)> <trt(5)>\n 1     unit1      trt1\n 2     unit2      trt4\n 3     unit3      trt3\n 4     unit4      trt5\n 5     unit5      trt2\n 6     unit6      trt5\n 7     unit7      trt3\n 8     unit8      trt4\n 9     unit9      trt2\n10     unit10     trt1\n# … with 20 more rows\n\n\nA design table generated by takeout() is an object with a special class of edbl_table. When you print a takeout object, a table will be displayed like a typical edbl_table object but the recipe code will also be displayed prior to the table.\nYou can quickly plot the design using the autoplot() in the deggust package.\n\nautoplot(crd)"
  },
  {
    "objectID": "cookbook.html#randomised-complete-block-design",
    "href": "cookbook.html#randomised-complete-block-design",
    "title": "5  Cookbook",
    "section": "5.2 Randomised complete block design",
    "text": "5.2 Randomised complete block design\nA randomised complete block design, commonly abbreviated as RCBD, is contain two unit factors, a blocking factor and experimental unit factor, and a treatment factor. The experimental unit factor would be nested within the blocking factor with the number of units within each level of the blocking factor, \\(k\\), equal to the number of treatments, \\(t\\). Every treatment appears exactly once in each level of the blocking factor, so the number of blocks, \\(b\\), is the same as the number of replications, \\(r\\), i.e. \\(b = r\\).\n\nrcbd <- takeout(menu_rcbd(t = 6, r = 10))\nexamine_recipe(rcbd)\n\ndesign(\"Randomised Complete Block Design\") %>%\n  set_units(block = 10,\n            unit = nested_in(block, 6)) %>%\n  set_trts(trt = 6) %>%\n  allot_trts(trt ~ unit) %>%\n  assign_trts(\"random\", seed = 874) %>%\n  serve_table()\n\n\n\nautoplot(rcbd)\n\n\n\n\nSuppose now I tell you that there are only 3 units in block 1 and 4 units in block 2, and 5 units in block 3, while other blocks can have 6 units. How would you modify your design then? Still generate an RCBD but randomly remove the treatment allocation to match the block size? In comparison to the previous design, this design has 6 less units so it’s possible to have 9 replicates for each treatment. Generally you’d want to get close to a balanced design as possible so you have roughly an equal amount of information on all your treatments. If you randomly remove the treatment allocation to match the required block size, there’s no guarantee that you’ll end up with a balanced design. You’ll also find that there’ll be no named experimental design that matches the description of your units so you won’t be able to just select a design from the menu. This is where the edibble system aids you. In the fundamental edibble system, you put the experimental structure first before thinking about the treatment assignment.\n\nmbd <- design(\"Modified Block Design\") %>%\n  set_units(block = 10,\n            unit = nested_in(block, \n                               1 ~ 3,\n                               2 ~ 4,\n                               3 ~ 5,\n                               . ~ 6)) %>%\n  set_trts(trt = 6) %>%\n  allot_trts(trt ~ unit) %>%\n  assign_trts(\"random\", seed = 326) %>%\n  serve_table()\n\n\nautoplot(mbd)\n\n\n\n\nYou can see below that the number of replications are equal across the treatments. You can try changing the seed number above to generate another set of design and see if it still holds true (it should!).\n\ntable(mbd$trt)\n\n\ntrt1 trt2 trt3 trt4 trt5 trt6 \n   9    9    9    9    9    9"
  },
  {
    "objectID": "cookbook.html#latin-square-design",
    "href": "cookbook.html#latin-square-design",
    "title": "5  Cookbook",
    "section": "5.3 Latin square design",
    "text": "5.3 Latin square design\n\nlsd <- takeout(menu_lsd(t = 6))\nexamine_recipe(lsd)\n\ndesign(\"Latin Square Design\") %>%\n  set_units(row = 6,\n            col = 6,\n            unit = crossed_by(row, col)) %>%\n  set_trts(trt = 6) %>%\n  allot_trts(trt ~ unit) %>%\n  assign_trts(\"random\", seed = 907) %>%\n  serve_table()\n\n\n\nautoplot(lsd)"
  },
  {
    "objectID": "cookbook.html#factorial-design",
    "href": "cookbook.html#factorial-design",
    "title": "5  Cookbook",
    "section": "5.4 Factorial design",
    "text": "5.4 Factorial design\n\nfac <- takeout(menu_factorial(trt = c(3, 2)))\nexamine_recipe(fac)\n\ndesign(\"Factorial Design\") %>%\n  set_units(unit = 54) %>%\n  set_trts(trt1 = 3,\n           trt2 = 2) %>%\n  allot_trts(~unit) %>%\n  assign_trts(\"random\", seed = 339) %>%\n  serve_table()\n\n\n\nautoplot(fac)"
  },
  {
    "objectID": "cookbook.html#balanced-incomplete-block-design",
    "href": "cookbook.html#balanced-incomplete-block-design",
    "title": "5  Cookbook",
    "section": "5.5 Balanced incomplete block design",
    "text": "5.5 Balanced incomplete block design\n\nbibd <- takeout(menu_bibd(t = 5, r = 10, k = 4))\nexamine_recipe(bibd)\n\ndesign(\"Balanced Incomplete Block Design\") %>%\n  set_units(block = 12,\n            unit = nested_in(block, 4)) %>%\n  set_trts(trt = 5) %>%\n  allot_trts(trt ~ unit) %>%\n  assign_trts(\"random\", seed = 32) %>%\n  serve_table()\n\n\n\nautoplot(bibd)"
  },
  {
    "objectID": "cookbook.html#split-plot-design",
    "href": "cookbook.html#split-plot-design",
    "title": "5  Cookbook",
    "section": "5.6 Split-plot design",
    "text": "5.6 Split-plot design\n\nspd <- takeout(menu_split(t1 = 2, t2 = 4, r = 10))\nexamine_recipe(spd)\n\ndesign(\"Split-Plot Design | Split-Unit Design\") %>%\n  set_units(mainplot = 20,\n             subplot = nested_in(mainplot, 4)) %>%\n  set_trts(trt1 = 2,\n           trt2 = 4) %>%\n  allot_trts(trt1 ~ mainplot,\n             trt2 ~ subplot) %>%\n  assign_trts(\"random\", seed = 666) %>%\n  serve_table()\n\n\n\nautoplot(spd)"
  },
  {
    "objectID": "cookbook.html#strip-plot-design",
    "href": "cookbook.html#strip-plot-design",
    "title": "5  Cookbook",
    "section": "5.7 Strip-plot design",
    "text": "5.7 Strip-plot design\n\nstrip <- takeout(menu_strip(t1 = 3, t2 = 4, r = 9))\nexamine_recipe(strip)\n\ndesign(\"Strip-Plot Design | Strip-Unit Design\") %>%\n  set_units(block = 9,\n            row = nested_in(block, 3),\n            col = nested_in(block, 4),\n            unit = nested_in(block, crossed_by(row, col))) %>%\n  set_trts(trt1 = 3,\n           trt2 = 4) %>%\n  allot_trts(trt1 ~ row,\n             trt2 ~ col) %>%\n  assign_trts(\"random\", seed = 987) %>%\n  serve_table()\n\n\n\nautoplot(strip) + facet_wrap(~block, scales = \"free\")"
  },
  {
    "objectID": "cookbook.html#graeco-latin-square-design",
    "href": "cookbook.html#graeco-latin-square-design",
    "title": "5  Cookbook",
    "section": "5.8 Graeco-Latin square design",
    "text": "5.8 Graeco-Latin square design\n\ngraeco <- takeout(menu_graeco(t = 9))\nexamine_recipe(graeco)\n\ndesign(\"Graeco-Latin Square Design\") %>%\n  set_units(row = 9,\n            col = 9,\n            unit = crossed_by(row, col)) %>%\n  set_trts(trt1 = 9,\n           trt2 = 9) %>%\n  allot_trts(trt1 ~ unit,\n             trt2 ~ unit) %>%\n  assign_trts(\"random\", seed = 149) %>%\n  serve_table()\n\n\n\nautoplot(graeco)"
  },
  {
    "objectID": "cookbook.html#hyper-graeco-latin-square-design",
    "href": "cookbook.html#hyper-graeco-latin-square-design",
    "title": "5  Cookbook",
    "section": "5.9 Hyper-Graeco-Latin square design",
    "text": "5.9 Hyper-Graeco-Latin square design\n\nhyper_graeco <- takeout(menu_hyper_graeco(t = 6))\nexamine_recipe(hyper_graeco)\n\ndesign(\"Hyper-Graeco-Latin Square Design\") %>%\n  set_units(block1 = 6,\n            block2 = 6,\n            block3 = 6,\n            block4 = 6,\n            unit = crossed_by(block1, block2, block3, block4)) %>%\n  set_trts(trt = 6) %>%\n  allot_trts(trt ~ unit) %>%\n  assign_trts(\"random\", seed = 49) %>%\n  serve_table()\n\n\n\nautoplot(hyper_graeco)\n\nWarning: Too manu units so 296 units dropped from the plot. If you want to see\nall, use `nnode_max = Inf` or use `page = 2` to see the next set."
  },
  {
    "objectID": "cookbook.html#youden-square-design",
    "href": "cookbook.html#youden-square-design",
    "title": "5  Cookbook",
    "section": "5.10 Youden square design",
    "text": "5.10 Youden square design\n\nyouden <- takeout(menu_youden(nc = 4, t = 5))\nexamine_recipe(youden)\n\ndesign(\"Youden Square Design\") %>%\n  set_units(row = 5,\n            col = 4,\n            unit = crossed_by(row, col)) %>%\n  set_trts(trt = 5) %>%\n  allot_trts(trt ~ unit) %>%\n  assign_trts(\"random\", seed = 901) %>%\n  serve_table()\n\n\n\nautoplot(youden)"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Bailey, Rosemary. 2008. Design of Comparative Experiments.\n\n\nFisher, Ronald. 1935. The Design of Experiments. Oliver; Boyd.\n\n\nWickham, H. 2010. “A Layered Grammar of Graphics.”\nJournal of Computational and Graphical Statistics: A Joint\nPublication of American Statistical Association, Institute of\nMathematical Statistics, Interface Foundation of North America.\n\n\nWickham, Hadley. 2016. Ggplot2: Elegant Graphics for Data\nAnalysis. Springer-Verlag New York. https://ggplot2.tidyverse.org.\n\n\nWilkinson, Leland. 2005. The Grammar of Graphics. Springer."
  }
]